/**
 * @file      pin_mapping.h (derived from MKL43Z4.usbdmHardware)
 * @version   1.2.0
 * @brief     Pin declarations for FRDM_KL43Z4
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stddef.h>
#include "derivative.h"

#include "pcr.h"

namespace USBDM {

   /*
    * Enable clock to ports
    *
    * @param mask Mask for PORTs to enable
    */
   static inline void enablePortClocks(uint32_t mask) {
      SIM->SCGC5 |=  mask;
   };
   
   /*
    * Disable clock to ports
    *
    * @param mask Mask for PORTs to disable
    */
   static inline void disablePortClocks(uint32_t mask) {
      SIM->SCGC5 &=  ~mask;
   };


} // End namespace USBDM

namespace USBDM {

/** Class to static check signal mapping is valid */
template<class Info, int signalNum> class CheckSignal {
#ifdef DEBUG_BUILD
   static_assert((signalNum<Info::numSignals), "Non-existent signal - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != UNMAPPED_PCR), "Signal is not mapped to a pin - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != INVALID_PCR),  "Signal doesn't exist in this device/package");
   static_assert((signalNum>=Info::numSignals)||((Info::info[signalNum].gpioBit == UNMAPPED_PCR)||(Info::info[signalNum].gpioBit == INVALID_PCR)||(Info::info[signalNum].gpioBit >= 0)), "Illegal signal");
#endif
};

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Pins used for Crystal Oscillator
 * @{
 */
#define USBDM_OSC0_IS_DEFINED 
/**
 * Peripheral information for OSC, Crystal Oscillator
 */
class Osc0Info {
public:
   //! Hardware base pointer
   static constexpr volatile OSC_Type *osc   = (volatile OSC_Type *)OSC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = 0;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:osc0_mk

   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t oscclk_clock = 32768UL;

   //! Frequency of 32K OSC Clock or Crystal (if applicable)
   static constexpr uint32_t osc32kclk_clock = 32768UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      OSC_CR_ERCLKEN(1)  | // External Reference Enable
      OSC_CR_EREFSTEN(0) | // External Reference Stop Enable
      OSC_CR_SCP(2);       // Oscillator load capacitance

   /**
    * Get OSC clock (internal, assumed available)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static constexpr uint32_t getInternalClock() {
      return oscclk_clock;
   }

   /**
    * Get OSCERCLK clock (external, masked by OSC_CR_ERCLKEN)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOscerClk() {
      return (osc->CR&OSC_CR_ERCLKEN_MASK)?getInternalClock():0;
   }

   /**
    * Get OSC32KCLK clock
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOsc32kClock() {
      return osc32kclk_clock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: XTAL0                = PTA19                          */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  19,  PORT_PCR_MUX(0)|pcrValue  },
         /*   1: EXTAL0               = PTA18                          */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  18,  PORT_PCR_MUX(0)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0xCU);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0xCU);
   }

};

/** 
 * End OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Pins used for Real Time Clock
 * @{
 */
#define USBDM_RTC_IS_DEFINED 
/**
 * Peripheral information for RTC, Real Time Clock
 */
class RtcInfo {
public:
   //! Hardware base pointer
   static constexpr volatile RTC_Type *rtc   = (volatile RTC_Type *)RTC_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_RTC_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {RTC_Alarm_IRQn, RTC_Seconds_IRQn};

   // Template:rtc_mkl03z4

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Frequency of clock supplied to RTC_CLKIN pin
   static constexpr uint32_t rtcclkin_clock = 32765U;

   //! Oscillator control register
   static constexpr uint32_t cr =
      RTC_CR_OSCE(0) | // Enables 32kHz oscillator [RTC_32K]
      RTC_CR_CLKO(0) | // Disables RTC 32kHz Clock Output
      RTC_CR_UM(0)   | // Update Mode
      RTC_CR_SUP(0)  | // Supervisor access
      RTC_CR_WPE(0)  | // Wakeup Pin Enable
      RTC_CR_SCP(2);   // RTC Oscillator load capacitance

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: RTC_CLKOUT           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: RTC_CLKIN            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End RTC_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Pins used for Multipurpose Clock Generator
 * @{
 */
#define USBDM_MCG_IS_DEFINED 
/**
 * Peripheral information for MCG, Multipurpose Clock Generator
 */
class McgInfo {
public:
   //! Hardware base pointer
   static constexpr volatile MCG_Type *mcg   = (volatile MCG_Type *)MCG_BasePtr;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:mcg_lite_mkl17z4

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   enum ClockMode {
      ClockMode_None     = -1,
      ClockMode_LIRC_8M  = 0,
      ClockMode_LIRC_2M,
      ClockMode_HIRC_48M,
      ClockMode_EXT,
   };

   struct ClockInfo {
      //! Clock Mode
      const ClockMode clockMode:8;
      //! Control Register 1
      const uint8_t c1;
      //! Control Register 2
      const uint8_t c2;
      //! Status and Control Register
      const uint8_t sc;
      //! Miscellaneous Control Register
      const uint8_t mc;
   };
   
   //! Frequency of Slow Internal Reference Clock [~2MHz]
   static constexpr uint32_t system_slow_lirc_clock = 2000000UL;
   
   //! Frequency of Fast Internal Reference Clock [~8MHz]
   static constexpr uint32_t system_fast_lirc_clock = 8000000UL;
   
   //! Frequency of High Speed Internal Reference Clock [~48MHz]
   static constexpr uint32_t system_hirc_clock      = 48000000UL;
   
   static const ClockInfo clockInfo[];
   
   /**
    * Get HIRC_CLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getMcgPclk() {
      if ((mcg->MC&MCG_MC_HIRCEN_MASK) || ((mcg->S&MCG_S_CLKST_MASK) == MCG_S_CLKST(0))) {
         return system_hirc_clock;
      }
      else {
         return 0;
      }
   }
   
   /**
    * Get LIRC_CLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getLircClk() {
      if ((mcg->C1&MCG_C1_IRCLKEN_MASK) || ((mcg->S&MCG_S_CLKST_MASK) == MCG_S_CLKST(1))) {
         if (mcg->C2 & MCG_C2_IRCS_MASK) {
            return system_fast_lirc_clock;
         }
         else {
            return system_slow_lirc_clock;
         }
      }
      else {
         return 0;
      }
   }
   
   /**
    * Get LIRC_DIV1_CLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getLircDiv1Clk() {
      return getLircClk()/(1<<((mcg->SC&MCG_SC_FCRDIV_MASK)>>MCG_SC_FCRDIV_SHIFT));
   }
   
   /**
    * Get MCGIRCLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getMcgIrClk() {
      return getLircDiv1Clk()/(1<<((mcg->MC&MCG_MC_LIRC_DIV2_MASK)>>MCG_MC_LIRC_DIV2_SHIFT));
   }
   
   /**
    * Get MCGOUTCLK
    *
    * @return frequency in Hz as uint32_t
    */
   static uint32_t getMcgOutclk() {
      switch (mcg->S&MCG_S_CLKST_MASK) {
      case MCG_S_CLKST(0): // HIRC
         return getMcgPclk();
      case MCG_S_CLKST(1): // LIRC (IRC2Mz/IRC8Mz)/DIV1
         return getLircDiv1Clk();
      case MCG_S_CLKST(2): // EXT (IRC48MHz)
         return Osc0Info::getInternalClock();
      default:
      case MCG_S_CLKST(3): // Reserved
         return 0;
      }
   }
};

/** 
 * End MCG_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Pins used for System Integration Module
 * @{
 */
#define USBDM_SIM_IS_DEFINED 
/**
 * Peripheral information for SIM, System Integration Module
 */
class SimInfo {
public:
   //! Hardware base pointer
   static constexpr volatile SIM_Type *sim   = (volatile SIM_Type *)SIM_BasePtr;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:sim_mkl43z4

   //! System Options Register 1
   static constexpr uint32_t sopt1 = 
      SIM_SOPT1_OSC32KSEL(0) |    // 32K oscillator clock select
      SIM_SOPT1_OSC32KOUT(0);     // 32K oscillator clock out pin select

   /**
    * Get ERCLK32K clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getErc32kClock() {
   
      switch(sim->SOPT1&SIM_SOPT1_OSC32KSEL_MASK) {
         default                     : return 0;
         case SIM_SOPT1_OSC32KSEL(0) : return Osc0Info::getOsc32kClock();
         case SIM_SOPT1_OSC32KSEL(2) : return RtcInfo::rtcclkin_clock;
         case SIM_SOPT1_OSC32KSEL(3) : return 1000;
      }
   }

   //! System Options Register 2
   static constexpr uint32_t sopt2 = 
      SIM_SOPT2_LPUART0SRC(1) |    // LPUART0 clock source select
      SIM_SOPT2_LPUART1SRC(3) |    // LPUART1 clock source select
      SIM_SOPT2_TPMSRC(3) |        // TPM clock source select
      SIM_SOPT2_FLEXIOSRC(3) |        // FLEXIO clock source select
      SIM_SOPT2_USBSRC(1) |        // USB clock source select
      SIM_SOPT2_CLKOUTSEL(4) |     // CLKOUT pin clock source select
      SIM_SOPT2_RTCCLKOUTSEL(1);   // RTC clock out select

   /**
    * Get Peripheral clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getPeripheralClock() {
      return McgInfo::getMcgPclk();
   }

   /**
    * Get LPUART0 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpuart0Clock() {
      
      switch(sim->SOPT2&SIM_SOPT2_LPUART0SRC_MASK) {
      default:
      case SIM_SOPT2_LPUART0SRC(0): return 0;
      case SIM_SOPT2_LPUART0SRC(1): return McgInfo::getMcgPclk();
      case SIM_SOPT2_LPUART0SRC(2): return Osc0Info::getOscerClk();
      case SIM_SOPT2_LPUART0SRC(3): return McgInfo::getMcgIrClk();
      }
   }

   /**
    * Get LPUART1 input clock frequency
    *
    * @return Frequency as a uint32_t in Hz
    */
   static uint32_t getLpuart1Clock() {
      
      switch(sim->SOPT2&SIM_SOPT2_LPUART1SRC_MASK) {
      default:
      case SIM_SOPT2_LPUART1SRC(0): return 0;
      case SIM_SOPT2_LPUART1SRC(1): return McgInfo::getMcgPclk();
      case SIM_SOPT2_LPUART1SRC(2): return Osc0Info::getOscerClk();
      case SIM_SOPT2_LPUART1SRC(3): return McgInfo::getMcgIrClk();
      }
   }

   /**
    * Get TPM input clock frequency
    *
    * @return TPM input clock frequency as a uint32_t in Hz
    */
   static uint32_t getTpmClock() {
      
      switch(sim->SOPT2&SIM_SOPT2_TPMSRC_MASK) {
      default:
      case SIM_SOPT2_TPMSRC(0): return 0;
      case SIM_SOPT2_TPMSRC(1): return McgInfo::getMcgPclk();
      case SIM_SOPT2_TPMSRC(2): return Osc0Info::getOscerClk();
      case SIM_SOPT2_TPMSRC(3): return McgInfo::getMcgIrClk();
      }
   }

   //! System Options Register 4
   static constexpr uint32_t sopt4 = 
      SIM_SOPT4_TPM2CLKSEL(0)  |   // TPM 2 External Clock Pin Select
      SIM_SOPT4_TPM1CLKSEL(0)  |   // TPM 1 External Clock Pin Select
      SIM_SOPT4_TPM0CLKSEL(0)  |   // TPM 0 External Clock Pin Select
      SIM_SOPT4_TPM2CH0SRC(0)  |   // TPM 1 channel 0 input capture source select
      SIM_SOPT4_TPM1CH0SRC(0);     // TPM 1 channel 0 input capture source select

   //! System Options Register 5
   static constexpr uint32_t sopt5 = 
      SIM_SOPT5_UART2ODE(0) |        // UART 2 Open Drain Enable
      SIM_SOPT5_LPUART1ODE(0) |        // LPUART 1 Open Drain Enable
      SIM_SOPT5_LPUART0ODE(0) |        // LPUART 0 Open Drain Enable
      SIM_SOPT5_LPUART0TXSRC(0) |      // LPUART 0 transmit data source select
      SIM_SOPT5_LPUART0RXSRC(0) |      // LPUART 0 receive data source select
      SIM_SOPT5_LPUART1TXSRC(0) |      // LPUART 1 transmit data source select
      SIM_SOPT5_LPUART1RXSRC(0);       // LPUART 1 receive data source select

   //! System Options Register 7
   static constexpr uint32_t sopt7 = 
      SIM_SOPT7_ADC0ALTTRGEN(0) |    // ADC0 alternate trigger enable
      SIM_SOPT7_ADC0PRETRGSEL(0) |   // ADC0 pretrigger select
      SIM_SOPT7_ADC0TRGSEL(0);       // ADC0 trigger select

   //! System Clock Divider Register 1
   static constexpr uint32_t clkdiv1 = 
      SIM_CLKDIV1_OUTDIV4(5)|  // Bus/Flash clock
      SIM_CLKDIV1_OUTDIV1(5);  // Core/system clock 

   /*
    * Enable clock to ports
    *
    * @param mask Mask for PORTs to enable
    */
   static void enablePortClocks(uint32_t mask) {
      sim->SCGC5 |=  mask;
   };

   /*
    * Disable clock to ports
    *
    * @param mask Mask for PORTs to disable
    */
   static void disablePortClocks(uint32_t mask) {
      sim->SCGC5 &=  ~mask;
   };

   /**
    * Initialise SIM registers
    */
   static void initRegs() {
      
      #ifdef SIM_SCGC4_USBOTG_MASK
      // The USB interface must be disabled for clock changes to have effect
      sim->SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
      #endif
   
      sim->SOPT1 = sopt1;
      sim->SOPT2 = sopt2;
      sim->SOPT4 = sopt4;
      sim->SOPT5 = sopt5;
      sim->SOPT7 = sopt7;
   
      sim->CLKDIV1 = clkdiv1;
   }
};

/** 
 * End SIM_Group
 * @}
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Pins used for Analogue Input
 * @{
 */
#define USBDM_ADC0_IS_DEFINED 
/**
 * Peripheral information for ADC, Analogue Input
 */
class Adc0Info {
public:
   //! Hardware base pointer
   static constexpr volatile ADC_Type *adc   = (volatile ADC_Type *)ADC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_ADC0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {ADC0_IRQn};

   // Template:adc0_diff_a

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  = 
       ADC_CFG1_ADICLK(3)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADLSMP(0)|
       ADC_CFG1_ADIV(0)|
       ADC_CFG1_ADLPC(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  = 
       ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       ADC_CFG2_ADLSTS(0)|
       ADC_CFG2_ADHSC(0)|
       ADC_CFG2_ADACKEN(0);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_REFSEL(0)|
       ADC_SC2_DMAEN(0)|
       ADC_SC2_ACREN(0b000)|
       ADC_SC2_ADTRG(0);

   //! Number of signals available in info table
   static constexpr int numSignals  = 40;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: ADC0_SE0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: ADC0_SE3             = PTE22 (LIGHT_SENS)             */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  22,  PORT_PCR_MUX(0)|pcrValue  },
         /*   4: ADC0_SE4b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: ADC0_SE5b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: ADC0_SE6b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: ADC0_SE7b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: ADC0_SE8             = PTB0 (A0)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  0,   PORT_PCR_MUX(0)|pcrValue  },
         /*   9: ADC0_SE9             = PTB1 (A1)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  1,   PORT_PCR_MUX(0)|pcrValue  },
         /*  10: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  11: ADC0_SE11            = PTC2 (A4)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  2,   PORT_PCR_MUX(0)|pcrValue  },
         /*  12: ADC0_SE12            = PTB2 (A2)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  2,   PORT_PCR_MUX(0)|pcrValue  },
         /*  13: ADC0_SE13            = PTB3 (A3)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  3,   PORT_PCR_MUX(0)|pcrValue  },
         /*  14: ADC0_SE14            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: ADC0_SE15            = PTC1 (A5)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  1,   PORT_PCR_MUX(0)|pcrValue  },
         /*  16: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  17: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  18: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  19: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  20: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  21: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  22: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  23: ADC0_SE23            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  24: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  25: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  26: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  27: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  28: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  29: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  30: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  31: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  32: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  33: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  34: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  35: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  36: ADC0_SE4a            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  37: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  38: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  39: ADC0_SE7a            = PTE23                          */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  23,  PORT_PCR_MUX(0)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      enablePortClocks(PORTC_CLOCK_MASK|PORTB_CLOCK_MASK|PORTE_CLOCK_MASK);

      ((PORT_Type *)PORTE_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0xC0U);
      ((PORT_Type *)PORTB_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0xFU);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x6U);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTC_CLOCK_MASK|PORTB_CLOCK_MASK|PORTE_CLOCK_MASK);

      ((PORT_Type *)PORTE_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0xC0U);
      ((PORT_Type *)PORTB_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0xFU);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x6U);
   }

   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC0_DP0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC0_DP3             = PTE22 (LIGHT_SENS)             */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  22,  PORT_PCR_MUX(0)|pcrValue  },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
         enablePortClocks(PORTE_CLOCK_MASK);

         ((PORT_Type *)PORTE_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x40U);
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
         enablePortClocks(PORTE_CLOCK_MASK);

         ((PORT_Type *)PORTE_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x40U);
      }

   }; 

   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC0_DM0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC0_DM3             = PTE23                          */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  23,  PORT_PCR_MUX(0)|pcrValue  },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
         enablePortClocks(PORTE_CLOCK_MASK);

         ((PORT_Type *)PORTE_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x80U);
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
         enablePortClocks(PORTE_CLOCK_MASK);

         ((PORT_Type *)PORTE_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x80U);
      }

   }; 

};

/** 
 * End ADC_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */
#define USBDM_CMP0_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator
 */
class Cmp0Info {
public:
   //! Hardware base pointer
   static constexpr volatile CMP_Type *cmp   = (volatile CMP_Type *)CMP0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMP0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMP0_IRQn};

   // Template:cmp0_pstm_trigm

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(0)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(0);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0)   | // Comparator Output Pin Enable
      CMP_CR1_EN(0);     // Comparator Module Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(0); // Filter Sample Period

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP0_IN0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: CMP0_IN1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   4: CMP0_IN4             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: CMP0_IN5             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP0_OUT             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End CMP_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Pins used for Control
 * @{
 */
#define USBDM_CONTROL_IS_DEFINED 
/**
 * Peripheral information for CONTROL, Control
 */
class ControlInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 6;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SWD_CLK              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: SWD_DIO              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: NMI_b                = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: RESET_b              = PTA20                          */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  20,  PORT_PCR_MUX(0)|pcrValue  },
         /*   4: CLKOUT               = PTC3                           */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  3,   PORT_PCR_MUX(5)|pcrValue  },
         /*   5: CLKOUT32K            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK|PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTC_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(5)|PORT_GPCLR_GPWE(0x8U);
      ((PORT_Type *)PORTA_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x10U);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK|PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTC_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x8U);
      ((PORT_Type *)PORTA_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x10U);
   }

};

/** 
 * End Control_Group
 * @}
 */
/**
 * @addtogroup DAC_Group DAC, Digital-to-Analogue Converter
 * @brief Pins used for Digital-to-Analogue Converter
 * @{
 */
#define USBDM_DAC0_IS_DEFINED 
/**
 * Peripheral information for DAC, Digital-to-Analogue Converter
 */
class Dac0Info {
public:
   //! Hardware base pointer
   static constexpr volatile DAC_Type *dac   = (volatile DAC_Type *)DAC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_DAC0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:dac0_2ch_fifo_mkl17

   //! DAC Control Register 0
   static constexpr uint32_t c0 =
      DAC_C0_DACRFS(1)        | // Reference Select
      DAC_C0_DACTRGSEL(1)     | // Trigger Select
      DAC_C0_LPEN(0)          | // Low Power Control
      DAC_C0_DACBWIEN(0)      | // Buffer Watermark Interrupt Enable
      DAC_C0_DACBTIEN(0)      | // Buffer Read Pointer Top Flag Interrupt Enable
      DAC_C0_DACBBIEN(0);       // Buffer Read Pointer Bottom Flag Interrupt Enable

   //! DAC Control Register 1
   static constexpr uint32_t c1 =
      DAC_C1_DMAEN(0)       | // DMA Enable Select
      DAC_C1_DACBFMD(0)     | // Buffer Work Mode Select
      DAC_C1_DACBFEN(0);      // Buffer Enable
   //! DAC Control Register 2
   static constexpr uint32_t c2 =
      DAC_C2_DACBFUP(1);   // DAC Buffer Upper Limit
   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: DAC0_OUT             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End DAC_Group
 * @}
 */
/**
 * @addtogroup DMA_TODO_Group DMA, (Incomplete)
 * @brief Pins used for (Incomplete)
 * @{
 */
#define USBDM_DMA0_IS_DEFINED 
/**
 * Peripheral information for DMA, (Incomplete)
 */
class Dma0Info {
public:
   //! Hardware base pointer
   static constexpr volatile DMA_Type *dma   = (volatile DMA_Type *)DMA0_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC7_DMA_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC7));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

};

/** 
 * End DMA_TODO_Group
 * @}
 */
/**
 * @addtogroup DMAMUX_Group DMAMUX, Direct Memory Access (DMA)
 * @brief Pins used for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMAMUX0_IS_DEFINED 
/**
 * Peripheral information for DMAMUX, Direct Memory Access (DMA)
 */
class Dmamux0Info {
public:
   //! Hardware base pointer
   static constexpr volatile DMAMUX_Type *dmamux   = (volatile DMAMUX_Type *)DMAMUX0_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_DMAMUX0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   /* DMA channel numbers */
   enum DmaChannels {
      DMA0_SLOT_Disabled                            = 0,
      DMA0_SLOT_LPUART0_Receive                     = 2,
      DMA0_SLOT_LPUART0_Transmit                    = 3,
      DMA0_SLOT_LPUART1_Receive                     = 4,
      DMA0_SLOT_LPUART1_Transmit                    = 5,
      DMA0_SLOT_UART2_Receive                       = 6,
      DMA0_SLOT_UART2_Transmit                      = 7,
      DMA0_SLOT_FlexIO_Ch0                          = 10,
      DMA0_SLOT_FlexIO_Ch1                          = 11,
      DMA0_SLOT_FlexIO_Ch2                          = 12,
      DMA0_SLOT_FlexIO_Ch3                          = 13,
      DMA0_SLOT_I2S0_Receive                        = 14,
      DMA0_SLOT_I2S0_Transmit                       = 15,
      DMA0_SLOT_SPI0_Receive                        = 16,
      DMA0_SLOT_SPI0_Transmit                       = 17,
      DMA0_SLOT_SPI1_Receive                        = 18,
      DMA0_SLOT_SPI1_Transmit                       = 19,
      DMA0_SLOT_I2C0                                = 22,
      DMA0_SLOT_I2C1                                = 23,
      DMA0_SLOT_TPM0_Ch_0                           = 24,
      DMA0_SLOT_TPM0_Ch_1                           = 25,
      DMA0_SLOT_TPM0_Ch_2                           = 26,
      DMA0_SLOT_TPM0_Ch_3                           = 27,
      DMA0_SLOT_TPM0_Ch_4                           = 28,
      DMA0_SLOT_TPM0_Ch_5                           = 29,
      DMA0_SLOT_TPM1_Ch_0                           = 32,
      DMA0_SLOT_TPM1_Ch_1                           = 33,
      DMA0_SLOT_TPM2_Ch_0                           = 34,
      DMA0_SLOT_TPM2_Ch_1                           = 35,
      DMA0_SLOT_ADC0                                = 40,
      DMA0_SLOT_CMP0                                = 42,
      DMA0_SLOT_DAC0                                = 45,
      DMA0_SLOT_PortA                               = 49,
      DMA0_SLOT_PortC                               = 51,
      DMA0_SLOT_PortD                               = 52,
      DMA0_SLOT_TPM0_Overflow                       = 54,
      DMA0_SLOT_TPM1_Overflow                       = 55,
      DMA0_SLOT_TPM2_Overflow                       = 56,
      DMA0_SLOT_AlwaysEnabled0                      = 60,
      DMA0_SLOT_AlwaysEnabled1                      = 61,
      DMA0_SLOT_AlwaysEnabled2                      = 62,
      DMA0_SLOT_AlwaysEnabled3                      = 63,
   };
};

/** 
 * End DMAMUX_Group
 * @}
 */
/**
 * @addtogroup EXTERNALTRIGGER_Group ExternalTrigger, Shared Resources
 * @brief Pins used for Shared Resources
 * @{
 */
#define USBDM_EXTERNALTRIGGER_IS_DEFINED 
/**
 * Peripheral information for ExternalTrigger, Shared Resources
 */
class ExternaltriggerInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: EXTRG_IN             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End EXTERNALTRIGGER_Group
 * @}
 */
/**
 * @addtogroup FLEXIO_TODO_Group FLEXIO, (Incomplete)
 * @brief Pins used for (Incomplete)
 * @{
 */
#define USBDM_FLEXIO_IS_DEFINED 
/**
 * Peripheral information for FLEXIO, (Incomplete)
 */
class FlexioInfo {
public:
   //! Hardware base pointer
   static constexpr volatile FLEXIO_Type *flexio   = (volatile FLEXIO_Type *)FLEXIO_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_FLEXIO_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC5));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART2_FLEXIO_IRQn};

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FXIO0_D0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FXIO0_D1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: FXIO0_D2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: FXIO0_D3             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: FXIO0_D4             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: FXIO0_D5             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: FXIO0_D6             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: FXIO0_D7             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End FLEXIO_TODO_Group
 * @}
 */
/**
 * @addtogroup FTFA_TODO_Group FTFA, (Incomplete)
 * @brief Pins used for (Incomplete)
 * @{
 */
#define USBDM_FTFA_IS_DEFINED 
/**
 * Peripheral information for FTFA, (Incomplete)
 */
class FtfaInfo {
public:
   //! Hardware base pointer
   static constexpr volatile FTFA_Type *ftfa   = (volatile FTFA_Type *)FTFA_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTF_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

};

/** 
 * End FTFA_TODO_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Pins used for Digital Input/Output
 * @{
 */
#define USBDM_GPIOA_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioAInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTA_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOA_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTA_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTA_IRQn};

};

#define USBDM_GPIOB_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioBInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTB_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOB_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTB_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

};

#define USBDM_GPIOC_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioCInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTC_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOC_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTCD_IRQn};

};

#define USBDM_GPIOD_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioDInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTD_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOD_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTD_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTCD_IRQn};

};

#define USBDM_GPIOE_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioEInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTE_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOE_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTE_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

};

/** 
 * End GPIO_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Pins used for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2C0_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface
 */
class I2c0Info {
public:
   //! Hardware base pointer
   static constexpr volatile I2C_Type *i2c   = (volatile I2C_Type *)I2C0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_I2C0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C0_IRQn};

   // Template:i2c0_mkl17

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C0_SCL             = PTE24 (ONBOARD_SCL)            */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  24,  PORT_PCR_MUX(5)|pcrValue  },
         /*   1: I2C0_SDA             = PTE25 (ONBOARD_SDA)            */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  25,  PORT_PCR_MUX(5)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      enablePortClocks(PORTE_CLOCK_MASK);

      ((PORT_Type *)PORTE_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(5)|PORT_GPCHR_GPWE(0x300U);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTE_CLOCK_MASK);

      ((PORT_Type *)PORTE_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x300U);
   }

};

#define USBDM_I2C1_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface
 */
class I2c1Info {
public:
   //! Hardware base pointer
   static constexpr volatile I2C_Type *i2c   = (volatile I2C_Type *)I2C1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_I2C1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C1_IRQn};

   // Template:i2c0_mkl17

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C1_SCL             = PTE1 (D15)                     */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  1,   PORT_PCR_MUX(6)|pcrValue  },
         /*   1: I2C1_SDA             = PTE0 (D14)                     */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  0,   PORT_PCR_MUX(6)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      enablePortClocks(PORTE_CLOCK_MASK);

      ((PORT_Type *)PORTE_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(6)|PORT_GPCLR_GPWE(0x3U);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTE_CLOCK_MASK);

      ((PORT_Type *)PORTE_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x3U);
   }

};

/** 
 * End I2C_Group
 * @}
 */
/**
 * @addtogroup I2S_Group I2S, Inter-Integrated-Circuit Interface
 * @brief Pins used for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2S0_IS_DEFINED 
/**
 * Peripheral information for I2S, Inter-Integrated-Circuit Interface
 */
class I2s0Info {
public:
   //! Hardware base pointer
   static constexpr volatile I2S_Type *i2s   = (volatile I2S_Type *)I2S0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_I2S_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2S0_IRQn};

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2S0_MCLK            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2S0_RX_BCLK         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: I2S0_RX_FS           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: I2S0_TX_BCLK         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: I2S0_TX_FS           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: I2S0_TXD0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: I2S0_RXD0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End I2S_Group
 * @}
 */
/**
 * @addtogroup LCD_Group LCD, LCD, Segment LCD
 * @brief Pins used for LCD, Segment LCD
 * @{
 */
#define USBDM_LCD_IS_DEFINED 
/**
 * Peripheral information for LCD, LCD, Segment LCD
 */
class LcdInfo {
public:
   //! Hardware base pointer
   static constexpr volatile LCD_Type *lcd   = (volatile LCD_Type *)LCD_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = 0;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_SLCD_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC5));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LCD_IRQn};

   // Template:lcd_mkl

   //! System Options Register 1
   static constexpr uint32_t gcr = 
      LCD_GCR_RVEN(0) |         // Regulated Voltage Enable
      LCD_GCR_RVTRIM(0b0001) |  // Regulated Voltage Trim
      LCD_GCR_CPSEL(0) |        // Charge Pump or Resistor Bias Select
      LCD_GCR_LADJ(0) |         // Load Adjust
      LCD_GCR_VSUPPLY(0) |      // Voltage Supply Control
      LCD_GCR_ALTDIV(0) |       // Clock divider
      LCD_GCR_FFR(0) |          // Fast Frame Rate Select
      LCD_GCR_LCDDOZE(0) |      // LCD Doze enable
      LCD_GCR_LCDSTP(0) |       // LCD Stop enable
      LCD_GCR_DUTY(3) |         // LCD duty select
      LCD_GCR_SOURCE(0)|LCD_GCR_ALTSOURCE(0); // Clock source

   //! Number of signals available in info table
   static constexpr int numSignals  = 61;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: LCD_P0               = PTB0 (A0)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  0,   PORT_PCR_MUX(0)|pcrValue  },
         /*   1: LCD_P1               = PTB1 (A1)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  1,   PORT_PCR_MUX(0)|pcrValue  },
         /*   2: LCD_P2               = PTB2 (A2)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  2,   PORT_PCR_MUX(0)|pcrValue  },
         /*   3: LCD_P3               = PTB3 (A3)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  3,   PORT_PCR_MUX(0)|pcrValue  },
         /*   4: LCD_P4               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: LCD_P5               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: LCD_P6               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   9: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  10: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  11: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  12: LCD_P12              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  13: LCD_P13              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  14: LCD_P14              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: LCD_P15              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  16: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  17: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  18: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  19: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  20: LCD_P20              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  21: LCD_P21              = PTC1 (A5)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  1,   PORT_PCR_MUX(0)|pcrValue  },
         /*  22: LCD_P22              = PTC2 (A4)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  2,   PORT_PCR_MUX(0)|pcrValue  },
         /*  23: LCD_P23              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  24: LCD_P24              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  25: LCD_P25              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  26: LCD_P26              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  27: LCD_P27              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  28: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  29: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  30: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  31: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  32: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  33: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  34: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  35: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  36: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  37: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  38: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  39: LCD_P39              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  40: LCD_P40              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  41: LCD_P41              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  42: LCD_P42              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  43: LCD_P43              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  44: LCD_P44              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  45: LCD_P45              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  46: LCD_P46              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  47: LCD_P47              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  48: LCD_P48              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  49: LCD_P49              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  50: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  51: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  52: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  53: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  54: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  55: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  56: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  57: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  58: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  59: LCD_P59              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  60: LCD_P60              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      enablePortClocks(PORTC_CLOCK_MASK|PORTB_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0xFU);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x6U);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTC_CLOCK_MASK|PORTB_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0xFU);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x6U);
   }

};

/** 
 * End LCD_Group
 * @}
 */
/**
 * @addtogroup Power_Group LCD_POWER, Power
 * @brief Pins used for Power
 * @{
 */
#define USBDM_LCD_POWER_IS_DEFINED 
/**
 * Peripheral information for LCD_POWER, Power
 */
class Lcd_powerInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 5;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VCAP1                = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: VCAP2                = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: VLL1                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: VLL2                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: VLL3                 = VLL3                           */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End Power_Group
 * @}
 */
/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Pins used for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_LLWU_IS_DEFINED 
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit
 */
class LlwuInfo {
public:
   //! Hardware base pointer
   static constexpr volatile LLWU_Type *llwu   = (volatile LLWU_Type *)LLWU_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   4: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   5: LLWU_P5              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: LLWU_P6              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: LLWU_P7              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: LLWU_P8              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: LLWU_P9              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: LLWU_P10             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  11: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  12: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  13: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  14: LLWU_P14             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: LLWU_P15             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End LLWU_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Pins used for Low Power Timer
 * @{
 */
#define USBDM_LPTMR0_IS_DEFINED 
/**
 * Peripheral information for LPTMR, Low Power Timer
 */
class Lptmr0Info {
public:
   //! Hardware base pointer
   static constexpr volatile LPTMR_Type *lptmr   = (volatile LPTMR_Type *)LPTMR0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_LPTMR_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC5));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LPTMR0_IRQn};

   // Template:lptmr0_0

   //! Default Timer Compare value
   static constexpr uint32_t cmr = 0;

   //! Default PSR value
   static constexpr uint32_t psr = 
      LPTMR_PSR_PRESCALE(0)|
      LPTMR_PSR_PBYP(0)|
      LPTMR_PSR_PCS(0);

   //! Default CSR value
   static constexpr uint32_t csr = 
      LPTMR_CSR_TIE(false)|
      LPTMR_CSR_TMS(0)|
      LPTMR_CSR_TFC(0)|
      LPTMR_CSR_TPP(0)|
      LPTMR_CSR_TPS(0);

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(lptmr->PSR&LPTMR_PSR_PCS_MASK) {
      default:
      case LPTMR_PSR_PCS(0): return McgInfo::getMcgIrClk();
      case LPTMR_PSR_PCS(1): return SystemLpoClock;
      case LPTMR_PSR_PCS(2): return SimInfo::getErc32kClock();
      case LPTMR_PSR_PCS(3): return Osc0Info::getOscerClk();
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: LPTMR0_ALT1          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: LPTMR0_ALT2          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End LPTMR_Group
 * @}
 */
/**
 * @addtogroup LPUART_Group LPUART, Low Power Universal Asynchronous Receiver/Transmitter
 * @brief Pins used for Low Power Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_LPUART0_IS_DEFINED 
/**
 * Peripheral information for LPUART, Low Power Universal Asynchronous Receiver/Transmitter
 */
class Lpuart0Info {
public:
   //! Hardware base pointer
   static constexpr volatile LPUART_Type *lpuart   = (volatile LPUART_Type *)LPUART0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_LPUART0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC5));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LPUART0_IRQn};

   // Template:lpuart0_mkl17

   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
      return SimInfo::getLpuart0Clock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: LPUART0_TX           = PTA2 (D1)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  2,   PORT_PCR_MUX(2)|pcrValue  },
         /*   1: LPUART0_RX           = PTA1 (D0)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  1,   PORT_PCR_MUX(2)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(2)|PORT_GPCLR_GPWE(0x6U);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x6U);
   }

};

#define USBDM_LPUART1_IS_DEFINED 
/**
 * Peripheral information for LPUART, Low Power Universal Asynchronous Receiver/Transmitter
 */
class Lpuart1Info {
public:
   //! Hardware base pointer
   static constexpr volatile LPUART_Type *lpuart   = (volatile LPUART_Type *)LPUART1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_LPUART1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC5));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LPUART1_IRQn};

   // Template:lpuart0_mkl17

   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
      return SimInfo::getLpuart1Clock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: LPUART1_TX           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: LPUART1_RX           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End LPUART_Group
 * @}
 */
/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Pins used for Programmable Interrupt Timer
 * @{
 */
#define USBDM_PIT_IS_DEFINED 
/**
 * Peripheral information for PIT, Programmable Interrupt Timer
 */
class PitInfo {
public:
   //! Hardware base pointer
   static constexpr volatile PIT_Type *pit   = (volatile PIT_Type *)PIT_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_PIT_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PIT_IRQn};

   // Template:pit_2ch_chain_ltmr

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Default value for PIT->SC register
   static constexpr uint32_t loadValue  = 
      10000;

   //! PIT operation in debug mode
   static constexpr uint32_t mcr = 
      PIT_MCR_FRZ(0);

};

/** 
 * End PIT_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Pins used for Power
 * @{
 */
#define USBDM_POWER_IS_DEFINED 
/**
 * Peripheral information for POWER, Power
 */
class PowerInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 12;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VDD1                 = VDD1                           */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: VDD2                 = VDD2                           */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: VDD3                 = VDD3                           */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   3: VDDA                 = VDDA (VDDA)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: VOUT33               = VOUT33 (VOUT33)                */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   5: VREFH                = VREFH (VREFH/VREF0_OUT)        */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: VREFL                = VREFL (VREFL)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   7: VREGIN               = VREGIN (VREGIN)                */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   8: VSS1                 = VSS1                           */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   9: VSS2                 = VSS2                           */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  10: VSS3                 = VSS3                           */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  11: VSSA                 = VSSA (VSSA)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End Power_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Pins used for Serial Peripheral Interface
 * @{
 */
#define USBDM_SPI0_IS_DEFINED 
/**
 * Peripheral information for SPI, Serial Peripheral Interface
 */
class Spi0Info {
public:
   //! Hardware base pointer
   static constexpr volatile SPI_Type *spi   = (volatile SPI_Type *)SPI0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_SPI0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {SPI0_IRQn};

   // Template:spi0_mkl_16bit

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

#ifdef SPI_CTAR_LSBFE_SHIFT
   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint32_t modeValue = 
      SPI_CTAR_LSBFE(0)| // LSB or MSB first
      SPI_CTAR_MODE(0);  // Mode (CPOL+CPHA)

#endif

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed = 
      10000000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SPI0_SCK             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: SPI0_MISO            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: SPI0_MOSI            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: SPI0_SS              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_SPI1_IS_DEFINED 
/**
 * Peripheral information for SPI, Serial Peripheral Interface
 */
class Spi1Info {
public:
   //! Hardware base pointer
   static constexpr volatile SPI_Type *spi   = (volatile SPI_Type *)SPI1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_SPI1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {SPI1_IRQn};

   // Template:spi0_mkl_16bit

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

#ifdef SPI_CTAR_LSBFE_SHIFT
   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint32_t modeValue = 
      SPI_CTAR_LSBFE(0)| // LSB or MSB first
      SPI_CTAR_MODE(0);  // Mode (CPOL+CPHA)

#endif

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed = 
      10000000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SPI1_SCK             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: SPI1_MISO            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: SPI1_MOSI            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: SPI1_SS              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End SPI_Group
 * @}
 */
/**
 * @addtogroup TPM_Group TPM, Shared Resources
 * @brief Pins used for Shared Resources
 * @{
 */
#define USBDM_TPM_IS_DEFINED 
/**
 * Peripheral information for TPM, Shared Resources
 */
class TpmInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: TPM_CLKIN0           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: TPM_CLKIN1           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_TPM0_IS_DEFINED 
/**
 * Peripheral information for TPM, PWM, Input capture and Output compare
 */
class Tpm0Info {
public:
   //! Hardware base pointer
   static constexpr volatile TPM_Type *tpm   = (volatile TPM_Type *)TPM0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_TPM0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {TPM0_IRQn};

   // Template:tpm0_6ch_pol

   //! Timer external input frequency 
   static constexpr uint32_t tpmExternalClock =  0;

   //! Default Timer Period
   static constexpr uint32_t period = 10000;

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       TPM_SC_CPWMS(0)|  // Centre-Aligned PWM Select
       TPM_SC_CMOD(1) |  // Clock Mode Selection
       TPM_SC_TOIE(0)|   // Timer Overflow Interrupt Enable
       TPM_SC_PS(0);     // Prescale Factor Selection 

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(tpm->SC&TPM_SC_CMOD_MASK) {
      default:
      case TPM_SC_CMOD(0): return 0;
      case TPM_SC_CMOD(1): return SimInfo::getTpmClock();
      case TPM_SC_CMOD(2): return tpmExternalClock;
      case TPM_SC_CMOD(3): return 0;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      return freq/(1<<((tpm->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      return freq/(1<<((tpm->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 6;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: TPM0_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: TPM0_CH1             = PTA4 (D4)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  4,   PORT_PCR_MUX(3)|pcrValue  },
         /*   2: TPM0_CH2             = PTE29 (D6)                     */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  29,  PORT_PCR_MUX(3)|pcrValue  },
         /*   3: TPM0_CH3             = PTD3 (D2)                      */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  3,   PORT_PCR_MUX(4)|pcrValue  },
         /*   4: TPM0_CH4             = PTD4 (D10)                     */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  4,   PORT_PCR_MUX(4)|pcrValue  },
         /*   5: TPM0_CH5             = PTD5 (D13/LED_GREEN)           */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  5,   PORT_PCR_MUX(4)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK|PORTE_CLOCK_MASK|PORTD_CLOCK_MASK);

      ((PORT_Type *)PORTD_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(4)|PORT_GPCLR_GPWE(0x38U);
      ((PORT_Type *)PORTE_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(3)|PORT_GPCHR_GPWE(0x2000U);
      ((PORT_Type *)PORTA_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(3)|PORT_GPCLR_GPWE(0x10U);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK|PORTE_CLOCK_MASK|PORTD_CLOCK_MASK);

      ((PORT_Type *)PORTD_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x38U);
      ((PORT_Type *)PORTE_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x2000U);
      ((PORT_Type *)PORTA_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x10U);
   }

};

#define USBDM_TPM1_IS_DEFINED 
/**
 * Peripheral information for TPM, PWM, Input capture and Output compare
 */
class Tpm1Info {
public:
   //! Hardware base pointer
   static constexpr volatile TPM_Type *tpm   = (volatile TPM_Type *)TPM1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_TPM1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {TPM1_IRQn};

   // Template:tpm1_2ch_pol

   //! Timer external input frequency 
   static constexpr uint32_t tpmExternalClock =  0;

   //! Default Timer Period
   static constexpr uint32_t period = 10000;

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       TPM_SC_CPWMS(0)|  // Centre-Aligned PWM Select
       TPM_SC_CMOD(1) |  // Clock Mode Selection
       TPM_SC_TOIE(0)|   // Timer Overflow Interrupt Enable
       TPM_SC_PS(0);     // Prescale Factor Selection 

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(tpm->SC&TPM_SC_CMOD_MASK) {
      default:
      case TPM_SC_CMOD(0): return 0;
      case TPM_SC_CMOD(1): return SimInfo::getTpmClock();
      case TPM_SC_CMOD(2): return tpmExternalClock;
      case TPM_SC_CMOD(3): return 0;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      return freq/(1<<((tpm->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      return freq/(1<<((tpm->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: TPM1_CH0             = PTA12 (D3)                     */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  12,  PORT_PCR_MUX(3)|pcrValue  },
         /*   1: TPM1_CH1             = PTA13 (D8)                     */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  13,  PORT_PCR_MUX(3)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(3)|PORT_GPCLR_GPWE(0x3000U);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x3000U);
   }

};

#define USBDM_TPM2_IS_DEFINED 
/**
 * Peripheral information for TPM, PWM, Input capture and Output compare
 */
class Tpm2Info {
public:
   //! Hardware base pointer
   static constexpr volatile TPM_Type *tpm   = (volatile TPM_Type *)TPM2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_TPM2_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {TPM2_IRQn};

   // Template:tpm1_2ch_pol

   //! Timer external input frequency 
   static constexpr uint32_t tpmExternalClock =  0;

   //! Default Timer Period
   static constexpr uint32_t period = 10000;

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       TPM_SC_CPWMS(0)|  // Centre-Aligned PWM Select
       TPM_SC_CMOD(1) |  // Clock Mode Selection
       TPM_SC_TOIE(0)|   // Timer Overflow Interrupt Enable
       TPM_SC_PS(0);     // Prescale Factor Selection 

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(tpm->SC&TPM_SC_CMOD_MASK) {
      default:
      case TPM_SC_CMOD(0): return 0;
      case TPM_SC_CMOD(1): return SimInfo::getTpmClock();
      case TPM_SC_CMOD(2): return tpmExternalClock;
      case TPM_SC_CMOD(3): return 0;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      return freq/(1<<((tpm->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      return freq/(1<<((tpm->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: TPM2_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: TPM2_CH1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End TPM_Group
 * @}
 */
/**
 * @addtogroup UART_Group UART, Universal Asynchronous Receiver/Transmitter
 * @brief Pins used for Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_UART2_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart2Info {
public:
   //! Hardware base pointer
   static constexpr volatile UART_Type *uart   = (volatile UART_Type *)UART2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART2_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART2_FLEXIO_IRQn};

   // Template:uart2_mkl17z4_c7816

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   static constexpr bool statusNeedsWrite = false;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART2_TX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART2_RX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End UART_Group
 * @}
 */
/**
 * @addtogroup USB_Group USB, USB OTG Controller
 * @brief Pins used for USB OTG Controller
 * @{
 */
#define USBDM_USB0_IS_DEFINED 
/**
 * Peripheral information for USB, USB OTG Controller
 */
class Usb0Info {
public:
   //! Hardware base pointer
   static constexpr volatile USB_Type *usb   = (volatile USB_Type *)USB0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_USBOTG_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {USB0_IRQn};

   // Template:usb0_clkrcv_a

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: USB0_DM              = USB0_DM (USB0_DM)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: USB0_DP              = USB0_DP (USB0_DP)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: USB_CLKIN            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: audioUSB_SOF_OUT     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End USB_Group
 * @}
 */
/**
 * @addtogroup VREF_Group VREF, Voltage Reference
 * @brief Pins used for Voltage Reference
 * @{
 */
#define USBDM_VREF_IS_DEFINED 
/**
 * Peripheral information for VREF, Voltage Reference
 */
class VrefInfo {
public:
   //! Hardware base pointer
   static constexpr volatile VREF_Type *vref   = (volatile VREF_Type *)VREF_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_VREF_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VREF0_OUT            = VREFH (VREFH/VREF0_OUT)        */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End VREF_Group
 * @}
 */

} // End namespace USBDM


#include "adc.h"
#include "tpm.h"
#include "gpio.h"

namespace USBDM {

/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Pins used for Analogue Input
 * @{
 */
using adc_A0               = const USBDM::Adc0Channel<8>;
using adc_A1               = const USBDM::Adc0Channel<9>;
using adc_A2               = const USBDM::Adc0Channel<12>;
using adc_A3               = const USBDM::Adc0Channel<13>;
using adc_A5               = const USBDM::Adc0Channel<15>;
using adc_A4               = const USBDM::Adc0Channel<11>;
using adc_LIGHT_SENS       = const USBDM::Adc0Channel<3>;
//using adc_LIGHT_SENS       = const USBDM::Adc0Channel<3>;
/** 
 * End ADC_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Pins used for Digital Input/Output
 * @{
 */
using gpio_D5              = const USBDM::GpioA<5>;
using gpio_D9              = const USBDM::GpioD<2>;
using gpio_D7              = const USBDM::GpioE<30>;
using gpio_LED_RED         = const USBDM::GpioE<31>;
/** 
 * End GPIO_Group
 * @}
 */
/**
 * @addtogroup TPM_Group TPM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */
using tpm_D4               = const USBDM::Tpm0Channel<1>;
using tpm_D2               = const USBDM::Tpm0Channel<3>;
using tpm_D10              = const USBDM::Tpm0Channel<4>;
using tpm_D13              = const USBDM::Tpm0Channel<5>;
using tpm_LED_GREEN        = const USBDM::Tpm0Channel<5>;
using tpm_D6               = const USBDM::Tpm0Channel<2>;
using tpm_D3               = const USBDM::Tpm1Channel<0>;
using tpm_D8               = const USBDM::Tpm1Channel<1>;
/** 
 * End TPM_Group
 * @}
 */
/**
 * Used to configure pin-mapping before 1st use of peripherals
 */
extern void mapAllPins();

} // End namespace USBDM

/**
 *
 * @mainpage Summary
 *
 * @section PinsByPinName Pins by Pin Name
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTA0                     | SWD_CLK                                     |                           | SWD       
 *  PTA1                     | LPUART0_RX                                  | D0                        | Console Rx       
 *  PTA2                     | LPUART0_TX                                  | D1                        | Console Tx       
 *  PTA3                     | SWD_DIO                                     |                           | SWD       
 *  PTA4                     | TPM0_CH1                                    | D4                        | Button 2       
 *  PTA5                     | GPIOA_5                                     | D5                        | -       
 *  PTA12                    | TPM1_CH0                                    | D3                        | -       
 *  PTA13                    | TPM1_CH1                                    | D8                        | -       
 *  PTA18                    | EXTAL0                                      |                           | 32K Crystal       
 *  PTA19                    | XTAL0                                       |                           | 32K Crystal       
 *  PTA20                    | RESET_b                                     |                           | Reset button       
 *  PTB0                     | LCD_P0/ADC0_SE8                             | A0                        | -       
 *  PTB1                     | LCD_P1/ADC0_SE9                             | A1                        | -       
 *  PTB2                     | LCD_P2/ADC0_SE12                            | A2                        | -       
 *  PTB3                     | LCD_P3/ADC0_SE13                            | A3                        | -       
 *  PTB16                    | LCD_P12                                     |                           | -       
 *  PTB17                    | LCD_P13                                     |                           | -       
 *  PTB18                    | LCD_P14                                     |                           | -       
 *  PTB19                    | LCD_P15                                     |                           | -       
 *  PTC0                     | LCD_P20/ADC0_SE14                           |                           | -       
 *  PTC1                     | LCD_P21/ADC0_SE15                           | A5                        | -       
 *  PTC2                     | LCD_P22/ADC0_SE11                           | A4                        | -       
 *  PTC3                     | CLKOUT                                      |                           | Button 1       
 *  PTC4                     | LCD_P24                                     |                           | -       
 *  PTC5                     | LCD_P25                                     | ACCEL_INT1/MAG_INT        | -       
 *  PTC6                     | LCD_P26/CMP0_IN0                            |                           | -       
 *  PTC7                     | LCD_P27/CMP0_IN1                            |                           | -       
 *  PTD0                     | LCD_P40                                     |                           | -       
 *  PTD1                     | LCD_P41/ADC0_SE5b                           | ACCEL_INT2                | -       
 *  PTD2                     | GPIOD_2                                     | D9                        | -       
 *  PTD3                     | TPM0_CH3                                    | D2                        | -       
 *  PTD4                     | TPM0_CH4                                    | D10                       | -       
 *  PTD5                     | TPM0_CH5                                    | D13/LED_GREEN             | Green LED       
 *  PTD6                     | LCD_P46/ADC0_SE7b                           | D11                       | -       
 *  PTD7                     | LCD_P47                                     | D12                       | -       
 *  PTE0                     | I2C1_SDA                                    | D14                       | -       
 *  PTE1                     | I2C1_SCL                                    | D15                       | -       
 *  PTE20                    | LCD_P59/ADC0_DP0/ADC0_SE0                   |                           | -       
 *  PTE21                    | LCD_P60/ADC0_DM0/ADC0_SE4a                  |                           | -       
 *  PTE22                    | ADC0_DP3/ADC0_SE3                           | LIGHT_SENS                | Light Sensor       
 *  PTE23                    | ADC0_DM3/ADC0_SE7a                          |                           | -       
 *  PTE24                    | I2C0_SCL                                    | ONBOARD_SCL               | Onboard I2C       
 *  PTE25                    | I2C0_SDA                                    | ONBOARD_SDA               | Onboard I2C       
 *  PTE29                    | TPM0_CH2                                    | D6                        | -       
 *  PTE30                    | GPIOE_30                                    | D7                        | -       
 *  PTE31                    | GPIOE_31                                    | LED_RED                   | Red LED       
 *  USB0_DM                  | USB0_DM                                     | USB0_DM                   | USB       
 *  USB0_DP                  | USB0_DP                                     | USB0_DP                   | USB       
 *  VCAP1                    | VCAP1                                       |                           | -       
 *  VCAP2                    | VCAP2                                       |                           | -       
 *  VDD1                     | VDD1                                        |                           | -       
 *  VDD2                     | VDD2                                        |                           | -       
 *  VDD3                     | VDD3                                        |                           | -       
 *  VDDA                     | VDDA                                        | VDDA                      | -       
 *  VLL1                     | VLL1                                        |                           | -       
 *  VLL2                     | VLL2                                        |                           | -       
 *  VLL3                     | VLL3                                        |                           | -       
 *  VOUT33                   | VOUT33                                      | VOUT33                    | -       
 *  VREFH                    | VREFH/VREF0_OUT                             | VREFH/VREF0_OUT           | -       
 *  VREFL                    | VREFL                                       | VREFL                     | -       
 *  VREGIN                   | VREGIN                                      | VREGIN                    | -       
 *  VSS1                     | VSS1                                        |                           | -       
 *  VSS2                     | VSS2                                        |                           | -       
 *  VSS3                     | VSS3                                        |                           | -       
 *  VSSA                     | VSSA                                        | VSSA                      | -       
 *
 *
 * @section PinsByLocation Pins by Location
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTB0                     | LCD_P0/ADC0_SE8                             | A0                        | -       
 *  PTB1                     | LCD_P1/ADC0_SE9                             | A1                        | -       
 *  PTB2                     | LCD_P2/ADC0_SE12                            | A2                        | -       
 *  PTB3                     | LCD_P3/ADC0_SE13                            | A3                        | -       
 *  PTC2                     | LCD_P22/ADC0_SE11                           | A4                        | -       
 *  PTC1                     | LCD_P21/ADC0_SE15                           | A5                        | -       
 *  PTC5                     | LCD_P25                                     | ACCEL_INT1/MAG_INT        | -       
 *  PTD1                     | LCD_P41/ADC0_SE5b                           | ACCEL_INT2                | -       
 *  PTA1                     | LPUART0_RX                                  | D0                        | Console Rx       
 *  PTA2                     | LPUART0_TX                                  | D1                        | Console Tx       
 *  PTD3                     | TPM0_CH3                                    | D2                        | -       
 *  PTA12                    | TPM1_CH0                                    | D3                        | -       
 *  PTA4                     | TPM0_CH1                                    | D4                        | Button 2       
 *  PTA5                     | GPIOA_5                                     | D5                        | -       
 *  PTE29                    | TPM0_CH2                                    | D6                        | -       
 *  PTE30                    | GPIOE_30                                    | D7                        | -       
 *  PTA13                    | TPM1_CH1                                    | D8                        | -       
 *  PTD2                     | GPIOD_2                                     | D9                        | -       
 *  PTD4                     | TPM0_CH4                                    | D10                       | -       
 *  PTD6                     | LCD_P46/ADC0_SE7b                           | D11                       | -       
 *  PTD7                     | LCD_P47                                     | D12                       | -       
 *  PTD5                     | TPM0_CH5                                    | D13/LED_GREEN             | Green LED       
 *  PTE0                     | I2C1_SDA                                    | D14                       | -       
 *  PTE1                     | I2C1_SCL                                    | D15                       | -       
 *  PTE31                    | GPIOE_31                                    | LED_RED                   | Red LED       
 *  PTE22                    | ADC0_DP3/ADC0_SE3                           | LIGHT_SENS                | Light Sensor       
 *  PTE24                    | I2C0_SCL                                    | ONBOARD_SCL               | Onboard I2C       
 *  PTE25                    | I2C0_SDA                                    | ONBOARD_SDA               | Onboard I2C       
 *  USB0_DM                  | USB0_DM                                     | USB0_DM                   | USB       
 *  USB0_DP                  | USB0_DP                                     | USB0_DP                   | USB       
 *  VDDA                     | VDDA                                        | VDDA                      | -       
 *  VOUT33                   | VOUT33                                      | VOUT33                    | -       
 *  VREFH                    | VREFH/VREF0_OUT                             | VREFH/VREF0_OUT           | -       
 *  VREFL                    | VREFL                                       | VREFL                     | -       
 *  VREGIN                   | VREGIN                                      | VREGIN                    | -       
 *  VSSA                     | VSSA                                        | VSSA                      | -       
 *
 *
 * @section PinsByFunction Pins by Function
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTE23                    | ADC0_DM3/ADC0_SE7a                          |                           | -       
 *  PTE22                    | ADC0_DP3/ADC0_SE3                           | LIGHT_SENS                | Light Sensor       
 *  PTC3                     | CLKOUT                                      |                           | Button 1       
 *  PTA18                    | EXTAL0                                      |                           | 32K Crystal       
 *  PTA5                     | GPIOA_5                                     | D5                        | -       
 *  PTD2                     | GPIOD_2                                     | D9                        | -       
 *  PTE30                    | GPIOE_30                                    | D7                        | -       
 *  PTE31                    | GPIOE_31                                    | LED_RED                   | Red LED       
 *  PTE24                    | I2C0_SCL                                    | ONBOARD_SCL               | Onboard I2C       
 *  PTE25                    | I2C0_SDA                                    | ONBOARD_SDA               | Onboard I2C       
 *  PTE1                     | I2C1_SCL                                    | D15                       | -       
 *  PTE0                     | I2C1_SDA                                    | D14                       | -       
 *  PTB0                     | LCD_P0/ADC0_SE8                             | A0                        | -       
 *  PTB1                     | LCD_P1/ADC0_SE9                             | A1                        | -       
 *  PTB2                     | LCD_P2/ADC0_SE12                            | A2                        | -       
 *  PTB3                     | LCD_P3/ADC0_SE13                            | A3                        | -       
 *  PTB16                    | LCD_P12                                     |                           | -       
 *  PTB17                    | LCD_P13                                     |                           | -       
 *  PTB18                    | LCD_P14                                     |                           | -       
 *  PTB19                    | LCD_P15                                     |                           | -       
 *  PTC0                     | LCD_P20/ADC0_SE14                           |                           | -       
 *  PTC1                     | LCD_P21/ADC0_SE15                           | A5                        | -       
 *  PTC2                     | LCD_P22/ADC0_SE11                           | A4                        | -       
 *  PTC4                     | LCD_P24                                     |                           | -       
 *  PTC5                     | LCD_P25                                     | ACCEL_INT1/MAG_INT        | -       
 *  PTC6                     | LCD_P26/CMP0_IN0                            |                           | -       
 *  PTC7                     | LCD_P27/CMP0_IN1                            |                           | -       
 *  PTD0                     | LCD_P40                                     |                           | -       
 *  PTD1                     | LCD_P41/ADC0_SE5b                           | ACCEL_INT2                | -       
 *  PTD6                     | LCD_P46/ADC0_SE7b                           | D11                       | -       
 *  PTD7                     | LCD_P47                                     | D12                       | -       
 *  PTE20                    | LCD_P59/ADC0_DP0/ADC0_SE0                   |                           | -       
 *  PTE21                    | LCD_P60/ADC0_DM0/ADC0_SE4a                  |                           | -       
 *  PTA1                     | LPUART0_RX                                  | D0                        | Console Rx       
 *  PTA2                     | LPUART0_TX                                  | D1                        | Console Tx       
 *  PTA20                    | RESET_b                                     |                           | Reset button       
 *  PTA0                     | SWD_CLK                                     |                           | SWD       
 *  PTA3                     | SWD_DIO                                     |                           | SWD       
 *  PTA4                     | TPM0_CH1                                    | D4                        | Button 2       
 *  PTE29                    | TPM0_CH2                                    | D6                        | -       
 *  PTD3                     | TPM0_CH3                                    | D2                        | -       
 *  PTD4                     | TPM0_CH4                                    | D10                       | -       
 *  PTD5                     | TPM0_CH5                                    | D13/LED_GREEN             | Green LED       
 *  PTA12                    | TPM1_CH0                                    | D3                        | -       
 *  PTA13                    | TPM1_CH1                                    | D8                        | -       
 *  USB0_DM                  | USB0_DM                                     | USB0_DM                   | USB       
 *  USB0_DP                  | USB0_DP                                     | USB0_DP                   | USB       
 *  VCAP1                    | VCAP1                                       |                           | -       
 *  VCAP2                    | VCAP2                                       |                           | -       
 *  VDD1                     | VDD1                                        |                           | -       
 *  VDD2                     | VDD2                                        |                           | -       
 *  VDD3                     | VDD3                                        |                           | -       
 *  VDDA                     | VDDA                                        | VDDA                      | -       
 *  VLL1                     | VLL1                                        |                           | -       
 *  VLL2                     | VLL2                                        |                           | -       
 *  VLL3                     | VLL3                                        |                           | -       
 *  VOUT33                   | VOUT33                                      | VOUT33                    | -       
 *  VREFH                    | VREFH/VREF0_OUT                             | VREFH/VREF0_OUT           | -       
 *  VREFL                    | VREFL                                       | VREFL                     | -       
 *  VREGIN                   | VREGIN                                      | VREGIN                    | -       
 *  VSS1                     | VSS1                                        |                           | -       
 *  VSS2                     | VSS2                                        |                           | -       
 *  VSS3                     | VSS3                                        |                           | -       
 *  VSSA                     | VSSA                                        | VSSA                      | -       
 *  PTA19                    | XTAL0                                       |                           | 32K Crystal       
 *
 */

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */

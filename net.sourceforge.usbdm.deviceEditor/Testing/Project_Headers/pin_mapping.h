/**
 * @file      pin_mapping.h (derived from MK22F51212.usbdmHardware)
 * @version   1.2.0
 * @brief     Pin declarations for FRDM_K22F
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stddef.h>
#include "derivative.h"

#include "pcr.h"

/*
 * Common Mux settings for PCR
 */
#undef FIXED_ADC_FN            
#undef FIXED_GPIO_FN           
#undef FIXED_PORT_CLOCK_REG    
#define FIXED_ADC_FN             0                    // Fixed ADC Multiplexing value
#define FIXED_GPIO_FN            1                    // Fixed GPIO Multiplexing value
#define FIXED_PORT_CLOCK_REG     SCGC5                // Fixed PORT Clock

/*
 * Peripheral clock macros
 */
#define PORT_CLOCK_REG       SCGC5

namespace USBDM {

/** Class to static check signal mapping is valid */
template<class Info, int signalNum> class CheckSignal {
#ifdef DEBUG_BUILD
   static_assert((signalNum<Info::numSignals), "Non-existent signal - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != UNMAPPED_PCR), "Signal is not mapped to a pin - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != INVALID_PCR),  "Signal doesn't exist in this device/package");
   static_assert((signalNum>=Info::numSignals)||((Info::info[signalNum].gpioBit == UNMAPPED_PCR)||(Info::info[signalNum].gpioBit == INVALID_PCR)||(Info::info[signalNum].gpioBit >= 0)), "Illegal signal");
#endif
};

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Pins used for Crystal Oscillator
 * @{
 */
#define USBDM_OSC0_IS_DEFINED 
/**
 * Peripheral information for OSC, Crystal Oscillator
 */
class Osc0Info {
public:
   //! Hardware base pointer
   static constexpr volatile OSC_Type *osc   = (volatile OSC_Type *)OSC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = 0;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:osc0_div

   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t oscclk_clock = 32000UL;

   //! Frequency of 32K OSC Clock or Crystal (if applicable)
   static constexpr uint32_t osc32kclk_clock = 32000UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      OSC_CR_ERCLKEN(0) |
      OSC_CR_EREFSTEN(0) |
      OSC_CR_SCP(2);

   //! OSC Clock divider register
   static constexpr uint32_t div =
      OSC_DIV_ERPS(0);   
   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: XTAL0                = PTA19 (XTAL0)                  */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  19,  PORT_PCR_MUX(0)|pcrValue  },
         /*   1: EXTAL0               = PTA18 (EXTAL0)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  18,  PORT_PCR_MUX(0)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Osc0Info,  0>::setPCR(); // XTAL0           = PTA19 (XTAL0)                 
      PcrTable_T<Osc0Info,  1>::setPCR(); // EXTAL0          = PTA18 (EXTAL0)                
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Osc0Info,  0>::setPCR(0); // XTAL0           = PTA19 (XTAL0)                 
      PcrTable_T<Osc0Info,  1>::setPCR(0); // EXTAL0          = PTA18 (EXTAL0)                
   }

};

/** 
 * End OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Pins used for Real Time Clock
 * @{
 */
#define USBDM_RTC_IS_DEFINED 
/**
 * Peripheral information for RTC, Real Time Clock
 */
class RtcInfo {
public:
   //! Hardware base pointer
   static constexpr volatile RTC_Type *rtc   = (volatile RTC_Type *)RTC_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_RTC_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {RTC_Alarm_IRQn, RTC_Seconds_IRQn};

   // Template:rtc_mk22f12810

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Frequency of RTC External Clock or Crystal
   static constexpr uint32_t rtcclk_clock = 32768UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      RTC_CR_OSCE(1) | // Enables 32kHz oscillator [RTC_32K]
      RTC_CR_CLKO(0) | // Disables RTC 32kHz Clock Output
      RTC_CR_UM(0)   | // Update Mode
      RTC_CR_SUP(0)  | // Supervisor access
      RTC_CR_WPE(0)  | // Wakeup Pin Enable
      RTC_CR_SCP(2);   // RTC Oscillator load capacitance

   //! Number of signals available in info table
   static constexpr int numSignals  = 5;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: XTAL32               = XTAL32 (XTAL32)                */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: EXTAL32              = EXTAL32 (EXTAL32)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: RTC_CLKOUT           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   4: RTC_WAKEUP_b         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End RTC_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Pins used for Multipurpose Clock Generator
 * @{
 */
#define USBDM_MCG_IS_DEFINED 
/**
 * Peripheral information for MCG, Multipurpose Clock Generator
 */
class McgInfo {
public:
   //! Hardware base pointer
   static constexpr volatile MCG_Type *mcg   = (volatile MCG_Type *)MCG_BasePtr;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:mcg_mk_ics48m

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Not present on these devices
   static constexpr int ERRATA_E2448 = 0;

   enum ClockMode {
      ClockMode_None = -1,
      ClockMode_FEI  = 0,
      ClockMode_FEE,
      ClockMode_FBI,
      ClockMode_BLPI,
      ClockMode_FBE,
      ClockMode_BLPE,
      ClockMode_PBE,
      ClockMode_PEE,
   };

   //! Frequency of Internal 48MHz Clock
   static constexpr uint32_t irc48m_clock = 48000000UL;

   //! Frequency of Slow Internal Reference Clock [~32kHz])
   static constexpr uint32_t system_slow_irc_clock = 32768UL;

   //! Frequency of Fast Internal Reference Clock [~4MHz])
   static constexpr uint32_t system_fast_irc_clock = 4000000UL;

   struct ClockInfo {
      //! Clock Mode
      const ClockMode clockMode:8;
      //! Control Register 1
      const uint8_t c1;
      //! Control Register 2
      const uint8_t c2;
      //! Control Register 4
      const uint8_t c4;
      //! Control Register 5
      const uint8_t c5;
      //! Control Register 6
      const uint8_t c6;
      //! Status and Control Register
      const uint8_t sc;
      //! Control Register 7
      const uint8_t c7;
      //! Control Register 8
      const uint8_t c8;
   };

   static const ClockInfo clockInfo[];
};

/** 
 * End MCG_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Pins used for System Integration Module
 * @{
 */
#define USBDM_SIM_IS_DEFINED 
/**
 * Peripheral information for SIM, System Integration Module
 */
class SimInfo {
public:
   //! Hardware base pointer
   static constexpr volatile SIM_Type *sim   = (volatile SIM_Type *)SIM_BasePtr;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:sim_mk22f51212

   //! System Options Register 1
   static constexpr uint32_t sopt1 = 
      SIM_SOPT1_OSC32KSEL(2) |    // 32K oscillator clock select
      SIM_SOPT1_OSC32KOUT(0);     // 32K oscillator clock out pin select

   //! System Options Register 2
   static constexpr uint32_t sopt2 = 
      SIM_SOPT2_LPUARTSRC(3) |     // LPUART clock source select
      SIM_SOPT2_USBSRC(1) |        // USB clock source select
      SIM_SOPT2_PLLFLLSEL(0) |     // PLL/FLL clock select
      SIM_SOPT2_CLKOUTSEL(2) |     // CLKOUT pin clock source select
      SIM_SOPT2_RTCCLKOUTSEL(1);   // RTC clock out select

   //! System Options Register 4
   static constexpr uint32_t sopt4 = 
      SIM_SOPT4_FTM3TRG1SRC(1) |   // FlexTimer 3 Hardware Trigger 1 Source Select
      SIM_SOPT4_FTM3TRG0SRC(1) |   // FlexTimer 3 Hardware Trigger 0 Source Select
      SIM_SOPT4_FTM0TRG1SRC(0) |   // FlexTimer 0 Hardware Trigger 1 Source Select
      SIM_SOPT4_FTM0TRG0SRC(0) |   // FlexTimer 0 Hardware Trigger 0 Source Select
      SIM_SOPT4_FTM3CLKSEL(0)  |   // FlexTimer 3 External Clock Pin Select
      SIM_SOPT4_FTM2CLKSEL(0)  |   // FlexTimer 2 External Clock Pin Select
      SIM_SOPT4_FTM1CLKSEL(0)  |   // FlexTimer 1 External Clock Pin Select
      SIM_SOPT4_FTM0CLKSEL(0)  |   // FlexTimer 0 External Clock Pin Select
      SIM_SOPT4_FTM2CH1SRC(0)  |   // FTM2 channel 1 input capture source select
      SIM_SOPT4_FTM2CH0SRC(0)  |   // FTM2 channel 0 input capture source select
      SIM_SOPT4_FTM1CH0SRC(0)  |   // FTM1 channel 0 input capture source select
      SIM_SOPT4_FTM3FLT0(0)    |   // FlexTimer 3 Fault 0 Select
      SIM_SOPT4_FTM2FLT0(0)    |   // FlexTimer 2 Fault 0 Select
      SIM_SOPT4_FTM1FLT0(0)    |   // FlexTimer 1 Fault 0 Select
      SIM_SOPT4_FTM0FLT1(0)    |   // FlexTimer 0 Fault 1 Select
      SIM_SOPT4_FTM0FLT0(0);       // FlexTimer 0 Fault 0 Select

   //! System Options Register 5
   static constexpr uint32_t sopt5 = 
      SIM_SOPT5_UART0TXSRC(0) |        // UART 0 transmit data source select
      SIM_SOPT5_UART0RXSRC(0) |        // UART 0 receive data source select
      SIM_SOPT5_UART1TXSRC(0) |        // UART 1 transmit data source select
      SIM_SOPT5_UART1RXSRC(0) |        // UART 1 receive data source select
      SIM_SOPT5_LPUART0RXSRC(0);   // LPUART 0 receive data source select

   //! System Options Register 7
   static constexpr uint32_t sopt7 = 
      SIM_SOPT7_ADC1ALTTRGEN(0) |    // ADC1 alternate trigger enable
      SIM_SOPT7_ADC1PRETRGSEL(0) |   // ADC1 pretrigger select
      SIM_SOPT7_ADC1TRGSEL(0) |      // ADC1 trigger select

      SIM_SOPT7_ADC0ALTTRGEN(0) |    // ADC0 alternate trigger enable
      SIM_SOPT7_ADC0PRETRGSEL(0) |   // ADC0 pretrigger select
      SIM_SOPT7_ADC0TRGSEL(0);       // ADC0 trigger select

   //! System Options Register 8
   static constexpr uint32_t sopt8 = 
      SIM_SOPT8_FTM3OCH7SRC(0) |   // FTM3 channel 7 output source
      SIM_SOPT8_FTM3OCH6SRC(0) |   // FTM3 channel 6 output source
      SIM_SOPT8_FTM3OCH5SRC(0) |   // FTM3 channel 5 output source
      SIM_SOPT8_FTM3OCH4SRC(0) |   // FTM3 channel 4 output source
      SIM_SOPT8_FTM3OCH3SRC(0) |   // FTM3 channel 3 output source
      SIM_SOPT8_FTM3OCH2SRC(0) |   // FTM3 channel 2 output source
      SIM_SOPT8_FTM3OCH1SRC(0) |   // FTM3 channel 1 output source
      SIM_SOPT8_FTM3OCH0SRC(3) |   // FTM3 channel 0 output source
      SIM_SOPT8_FTM0OCH7SRC(0) |   // FTM0 channel 7 output source
      SIM_SOPT8_FTM0OCH6SRC(0) |   // FTM0 channel 6 output source
      SIM_SOPT8_FTM0OCH5SRC(0) |   // FTM0 channel 5 output source
      SIM_SOPT8_FTM0OCH4SRC(0) |   // FTM0 channel 4 output source
      SIM_SOPT8_FTM0OCH3SRC(0) |   // FTM0 channel 3 output source
      SIM_SOPT8_FTM0OCH2SRC(0) |   // FTM0 channel 2 output source
      SIM_SOPT8_FTM0OCH1SRC(0) |   // FTM0 channel 1 output source
      SIM_SOPT8_FTM0OCH0SRC(0);    // FTM0 channel 0 output source

   //! System Clock Divider Register 1
   static constexpr uint32_t clkdiv1 = 
      SIM_CLKDIV1_OUTDIV4(15)|  // Flash clock
      SIM_CLKDIV1_OUTDIV3(15)|  // FlexBus clock
      SIM_CLKDIV1_OUTDIV2(15)|  // Bus clock
      SIM_CLKDIV1_OUTDIV1(15);  // Core/system clock 

   //! System Clock Divider Register 2
   static constexpr uint32_t clkdiv2 = 
      2;  // USB clock divider divisor & fraction 

   /**
    * Get Peripheral clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getPeripheralClockFrequency() {
      switch(SIM->SOPT2&SIM_SOPT2_PLLFLLSEL_MASK) {
      default:
      case SIM_SOPT2_PLLFLLSEL(0): return SystemMcgFllClock;
      case SIM_SOPT2_PLLFLLSEL(1): return SystemMcgPllClock;
      case SIM_SOPT2_PLLFLLSEL(2): return 0;
      case SIM_SOPT2_PLLFLLSEL(3): return McgInfo::irc48m_clock;
      }
   }

   /**
    * Get input clock frequency
    *
    * @return LPUART input clock frequency as a uint32_t in Hz
    */
   static uint32_t getLpuartInputClockFrequency() {
      switch(SIM->SOPT2&SIM_SOPT2_LPUARTSRC_MASK) {
      default:
      case SIM_SOPT2_LPUARTSRC(0): return 0;
      case SIM_SOPT2_LPUARTSRC(1): return getPeripheralClockFrequency();
      case SIM_SOPT2_LPUARTSRC(2): return SystemOscerClock;
      case SIM_SOPT2_LPUARTSRC(3): return SystemMcgirClock;
      }
   }

   /**
    * Get LPUART clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getLpuartClockFrequency() {
      switch(SIM->SOPT2&SIM_SOPT2_LPUARTSRC_MASK) {
      default:
      case SIM_SOPT2_LPUARTSRC(0): return 0;
      case SIM_SOPT2_LPUARTSRC(1):
   #ifdef SIM_CLKDIV3_PLLFLLFRAC_MASK
         {
         int  pllfllfrac  = (SIM->CLKDIV3&SIM_CLKDIV3_PLLFLLFRAC_MASK)>>SIM_CLKDIV3_PLLFLLFRAC_SHIFT;
         int  pllflldiv   = (SIM->CLKDIV3&SIM_CLKDIV3_PLLFLLDIV_MASK)>>SIM_CLKDIV3_PLLFLLDIV_SHIFT;
         return (SystemPeripheralClock*(pllfllfrac+1))/(pllflldiv+1);
         }
   #else
         return SystemPeripheralClock;
   #endif
      case SIM_SOPT2_LPUARTSRC(2): return SystemOscerClock;
      case SIM_SOPT2_LPUARTSRC(3): return SystemMcgirClock;
      }
   }

   static void initRegs() {
      
      #ifdef SIM_SCGC4_USBOTG_MASK
      // The USB interface must be disabled for clock changes to have effect
      SIM->SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
      #endif
   
      SIM->SOPT1 = sopt1;
      SIM->SOPT2 = sopt2;
      SIM->SOPT4 = sopt4;
      SIM->SOPT5 = sopt5;
      SIM->SOPT7 = sopt7;
      SIM->SOPT8 = sopt8;
   
      SIM->CLKDIV1 = clkdiv1;
      SIM->CLKDIV2 = clkdiv2;
   }
};

/** 
 * End SIM_Group
 * @}
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Pins used for Analogue Input
 * @{
 */
#define USBDM_ADC0_IS_DEFINED 
/**
 * Peripheral information for ADC, Analogue Input
 */
class Adc0Info {
public:
   //! Hardware base pointer
   static constexpr volatile ADC_Type *adc   = (volatile ADC_Type *)ADC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_ADC0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {ADC0_IRQn};

   // Template:adc0_diff_a

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  = 
       ADC_CFG1_ADICLK(3)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADLSMP(0)|
       ADC_CFG1_ADIV(0)|
       ADC_CFG1_ADLPC(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  = 
       ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       ADC_CFG2_ADLSTS(0)|
       ADC_CFG2_ADHSC(0)|
       ADC_CFG2_ADACKEN(0);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_REFSEL(0)|
       ADC_SC2_DMAEN(0)|
       ADC_SC2_ACREN(0b000)|
       ADC_SC2_ADTRG(0);

   //! Number of signals available in info table
   static constexpr int numSignals  = 24;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: ADC0_SE0             = ADC0_DP0 (A6/J24_1)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: ADC0_SE3             = ADC1_DP0 (A8/J24_5)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: ADC0_SE4b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: ADC0_SE5b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: ADC0_SE6b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: ADC0_SE7b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: ADC0_SE8             = PTB0 (A0/J24_2)                */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  0,   PORT_PCR_MUX(0)|pcrValue  },
         /*   9: ADC0_SE9             = PTB1 (A1/J24_4)                */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  1,   PORT_PCR_MUX(0)|pcrValue  },
         /*  10: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  11: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  12: ADC0_SE12            = PTB2 (A5/J24_12/ONBOARD_SCL)   */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  2,   PORT_PCR_MUX(0)|pcrValue  },
         /*  13: ADC0_SE13            = PTB3 (A4/J24_10/ONBOARD_SDA)   */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  3,   PORT_PCR_MUX(0)|pcrValue  },
         /*  14: ADC0_SE14            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: ADC0_SE15            = PTC1 (A2/J24_6/SW2)            */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  1,   PORT_PCR_MUX(0)|pcrValue  },
         /*  16: ADC0_SE16            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  17: ADC0_SE17            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  18: ADC0_SE18            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  19: ADC0_SE19            = ADC0_DM0 (A7/J24_3)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  20: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  21: ADC0_SE21            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  22: ADC0_SE22            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  23: ADC0_SE23            = DAC0_OUT (A11/J24_11)          */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Adc0Info,  8>::setPCR(); // ADC0_SE8        = PTB0 (A0/J24_2)               
      PcrTable_T<Adc0Info,  9>::setPCR(); // ADC0_SE9        = PTB1 (A1/J24_4)               
      PcrTable_T<Adc0Info, 12>::setPCR(); // ADC0_SE12       = PTB2 (A5/J24_12/ONBOARD_SCL)  
      PcrTable_T<Adc0Info, 13>::setPCR(); // ADC0_SE13       = PTB3 (A4/J24_10/ONBOARD_SDA)  
      PcrTable_T<Adc0Info, 15>::setPCR(); // ADC0_SE15       = PTC1 (A2/J24_6/SW2)           
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Adc0Info,  8>::setPCR(0); // ADC0_SE8        = PTB0 (A0/J24_2)               
      PcrTable_T<Adc0Info,  9>::setPCR(0); // ADC0_SE9        = PTB1 (A1/J24_4)               
      PcrTable_T<Adc0Info, 12>::setPCR(0); // ADC0_SE12       = PTB2 (A5/J24_12/ONBOARD_SCL)  
      PcrTable_T<Adc0Info, 13>::setPCR(0); // ADC0_SE13       = PTB3 (A4/J24_10/ONBOARD_SDA)  
      PcrTable_T<Adc0Info, 15>::setPCR(0); // ADC0_SE15       = PTC1 (A2/J24_6/SW2)           
   }

   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC0_DP0             = ADC0_DP0 (A6/J24_1)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: ADC0_DP1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   2: ADC0_DP2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   3: ADC0_DP3             = ADC1_DP0 (A8/J24_5)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC0_DM0             = ADC0_DM0 (A7/J24_3)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: ADC0_DM1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   2: ADC0_DM2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   3: ADC0_DM3             = ADC1_DM0 (A9/J24_7)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_ADC1_IS_DEFINED 
/**
 * Peripheral information for ADC, Analogue Input
 */
class Adc1Info {
public:
   //! Hardware base pointer
   static constexpr volatile ADC_Type *adc   = (volatile ADC_Type *)ADC1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_ADC1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {ADC1_IRQn};

   // Template:adc0_diff_a

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  = 
       ADC_CFG1_ADICLK(0)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADLSMP(0)|
       ADC_CFG1_ADIV(0)|
       ADC_CFG1_ADLPC(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  = 
       ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       ADC_CFG2_ADLSTS(0)|
       ADC_CFG2_ADHSC(0)|
       ADC_CFG2_ADACKEN(0);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_REFSEL(0)|
       ADC_SC2_DMAEN(0)|
       ADC_SC2_ACREN(0b000)|
       ADC_SC2_ADTRG(0);

   //! Number of signals available in info table
   static constexpr int numSignals  = 40;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: ADC1_SE0             = ADC1_DP0 (A8/J24_5)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   4: ADC1_SE4b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: ADC1_SE5b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: ADC1_SE6b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: ADC1_SE7b            = PTC11                          */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  11,  PORT_PCR_MUX(0)|pcrValue  },
         /*   8: ADC1_SE8             = PTB0 (A0/J24_2)                */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  0,   PORT_PCR_MUX(0)|pcrValue  },
         /*   9: ADC1_SE9             = PTB1 (A1/J24_4)                */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  1,   PORT_PCR_MUX(0)|pcrValue  },
         /*  10: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  11: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  12: ADC1_SE12            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  13: ADC1_SE13            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  14: ADC1_SE14            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: ADC1_SE15            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  16: ADC1_SE16            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  17: ADC1_SE17            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  18: ADC1_SE18            = VREF_OUT (D24)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  19: ADC1_SE19            = ADC1_DM0 (A9/J24_7)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  20: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  21: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  22: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  23: ADC1_SE23            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  24: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  25: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  26: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  27: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  28: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  29: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  30: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  31: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  32: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  33: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  34: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  35: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  36: ADC1_SE4a            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  37: ADC1_SE5a            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  38: ADC1_SE6a            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  39: ADC1_SE7a            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Adc1Info,  7>::setPCR(); // ADC1_SE7b       = PTC11                         
      PcrTable_T<Adc1Info,  8>::setPCR(); // ADC1_SE8        = PTB0 (A0/J24_2)               
      PcrTable_T<Adc1Info,  9>::setPCR(); // ADC1_SE9        = PTB1 (A1/J24_4)               
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Adc1Info,  7>::setPCR(0); // ADC1_SE7b       = PTC11                         
      PcrTable_T<Adc1Info,  8>::setPCR(0); // ADC1_SE8        = PTB0 (A0/J24_2)               
      PcrTable_T<Adc1Info,  9>::setPCR(0); // ADC1_SE9        = PTB1 (A1/J24_4)               
   }

   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC1_DP0             = ADC1_DP0 (A8/J24_5)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: ADC1_DP1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC1_DP3             = ADC0_DP0 (A6/J24_1)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC1_DM0             = ADC1_DM0 (A9/J24_7)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: ADC1_DM1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC1_DM3             = ADC0_DM0 (A7/J24_3)            */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End ADC_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */
#define USBDM_CMP0_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator
 */
class Cmp0Info {
public:
   //! Hardware base pointer
   static constexpr volatile CMP_Type *cmp   = (volatile CMP_Type *)CMP0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMP_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMP0_IRQn};

   // Template:cmp0_mkv

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(0)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(0);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0)   | // Comparator Output Pin Enable
      CMP_CR1_EN(0);     // Comparator Module Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(0); // Filter Sample Period

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP0_IN0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: CMP0_IN1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: CMP0_IN2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: CMP0_IN3             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: CMP0_IN4             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: CMP0_IN5             = VREF_OUT (D24)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP0_OUT             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_CMP1_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator
 */
class Cmp1Info {
public:
   //! Hardware base pointer
   static constexpr volatile CMP_Type *cmp   = (volatile CMP_Type *)CMP1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMP_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMP1_IRQn};

   // Template:cmp0_mkv

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(0)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(0);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0)   | // Comparator Output Pin Enable
      CMP_CR1_EN(0);     // Comparator Module Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(0); // Filter Sample Period

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP1_IN0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: CMP1_IN1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: CMP1_IN2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: CMP1_IN3             = DAC0_OUT (A11/J24_11)          */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   5: CMP1_IN5             = VREF_OUT (D24)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP1_OUT             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End CMP_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Pins used for Control
 * @{
 */
#define USBDM_CONTROL_IS_DEFINED 
/**
 * Peripheral information for CONTROL, Control
 */
class ControlInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 12;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: RESET_b              = RESET_b (RESET_b)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: JTAG_TCLK            = PTA0 (SWD_CLK)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  0,   PORT_PCR_MUX(7)|pcrValue  },
         /*   2: SWD_CLK              = PTA0 (SWD_CLK)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  0,   PORT_PCR_MUX(7)|pcrValue  },
         /*   3: JTAG_TDI             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: JTAG_TDO             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: TRACE_SWO            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: JTAG_TMS             = PTA3 (SWD_DIO)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  3,   PORT_PCR_MUX(7)|pcrValue  },
         /*   7: SWD_DIO              = PTA3 (SWD_DIO)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  3,   PORT_PCR_MUX(7)|pcrValue  },
         /*   8: NMI_b                = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: JTAG_TRST_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: CLKOUT               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  11: CLKOUT32K            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<ControlInfo,  1>::setPCR(); // JTAG_TCLK       = PTA0 (SWD_CLK)                
      PcrTable_T<ControlInfo,  2>::setPCR(); // SWD_CLK         = PTA0 (SWD_CLK)                
      PcrTable_T<ControlInfo,  6>::setPCR(); // JTAG_TMS        = PTA3 (SWD_DIO)                
      PcrTable_T<ControlInfo,  7>::setPCR(); // SWD_DIO         = PTA3 (SWD_DIO)                
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<ControlInfo,  1>::setPCR(0); // JTAG_TCLK       = PTA0 (SWD_CLK)                
      PcrTable_T<ControlInfo,  2>::setPCR(0); // SWD_CLK         = PTA0 (SWD_CLK)                
      PcrTable_T<ControlInfo,  6>::setPCR(0); // JTAG_TMS        = PTA3 (SWD_DIO)                
      PcrTable_T<ControlInfo,  7>::setPCR(0); // SWD_DIO         = PTA3 (SWD_DIO)                
   }

};

/** 
 * End Control_Group
 * @}
 */
/**
 * @addtogroup DAC_Group DAC, Digital-to-Analogue Converter
 * @brief Pins used for Digital-to-Analogue Converter
 * @{
 */
#define USBDM_DAC0_IS_DEFINED 
/**
 * Peripheral information for DAC, Digital-to-Analogue Converter
 */
class Dac0Info {
public:
   //! Hardware base pointer
   static constexpr volatile DAC_Type *dac   = (volatile DAC_Type *)DAC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_DAC0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {DAC0_IRQn};

   // Template:dac0_16ch_fifo16

   //! DAC Control Register 0
   static constexpr uint32_t c0 =
      DAC_C0_DACRFS(1)        | // Reference Select
      DAC_C0_DACTRGSEL(1)     | // Trigger Select
      DAC_C0_LPEN(0)          | // Low Power Control
      DAC_C0_DACBWIEN(0)      | // Buffer Watermark Interrupt Enable
      DAC_C0_DACBTIEN(0)      | // Buffer Read Pointer Top Flag Interrupt Enable
      DAC_C0_DACBBIEN(0);       // Buffer Read Pointer Bottom Flag Interrupt Enable

   //! DAC Control Register 1
   static constexpr uint32_t c1 =
      DAC_C1_DMAEN(0)       | // DMA Enable Select
      DAC_C1_DACBFWM(0)     | // Buffer Watermark Select
      DAC_C1_DACBFMD(0)     | // Buffer Work Mode Select
      DAC_C1_DACBFEN(0);      // Buffer Enable
   //! DAC Control Register 2
   static constexpr uint32_t c2 =
      DAC_C2_DACBFUP(1);   // DAC Buffer Upper Limit
   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: DAC0_OUT             = DAC0_OUT (A11/J24_11)          */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_DAC1_IS_DEFINED 
/**
 * Peripheral information for DAC, Digital-to-Analogue Converter
 */
class Dac1Info {
public:
   //! Hardware base pointer
   static constexpr volatile DAC_Type *dac   = (volatile DAC_Type *)DAC1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:dac0_16ch_fifo16

   //! DAC Control Register 0
   static constexpr uint32_t c0 =
      DAC_C0_DACRFS(1)        | // Reference Select
      DAC_C0_DACTRGSEL(1)     | // Trigger Select
      DAC_C0_LPEN(0)          | // Low Power Control
      DAC_C0_DACBWIEN(0)      | // Buffer Watermark Interrupt Enable
      DAC_C0_DACBTIEN(0)      | // Buffer Read Pointer Top Flag Interrupt Enable
      DAC_C0_DACBBIEN(0);       // Buffer Read Pointer Bottom Flag Interrupt Enable

   //! DAC Control Register 1
   static constexpr uint32_t c1 =
      DAC_C1_DMAEN(0)       | // DMA Enable Select
      DAC_C1_DACBFWM(0)     | // Buffer Watermark Select
      DAC_C1_DACBFMD(0)     | // Buffer Work Mode Select
      DAC_C1_DACBFEN(0);      // Buffer Enable
   //! DAC Control Register 2
   static constexpr uint32_t c2 =
      DAC_C2_DACBFUP(1);   // DAC Buffer Upper Limit
   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: DAC1_OUT             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End DAC_Group
 * @}
 */
/**
 * @addtogroup DMA_TODO_Group DMA, (Incomplete)
 * @brief Pins used for (Incomplete)
 * @{
 */
#define USBDM_DMA0_IS_DEFINED 
/**
 * Peripheral information for DMA, (Incomplete)
 */
class Dma0Info {
public:
   //! Hardware base pointer
   static constexpr volatile DMA_Type *dma   = (volatile DMA_Type *)DMA0_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC7_DMA_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC7));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

};

/** 
 * End DMA_TODO_Group
 * @}
 */
/**
 * @addtogroup DMAMUX_Group DMAMUX, Direct Memory Access (DMA)
 * @brief Pins used for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMAMUX0_IS_DEFINED 
/**
 * Peripheral information for DMAMUX, Direct Memory Access (DMA)
 */
class Dmamux0Info {
public:
   //! Hardware base pointer
   static constexpr volatile DMAMUX_Type *dmamux   = (volatile DMAMUX_Type *)DMAMUX0_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_DMAMUX0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   /* DMA channel numbers */
   enum DmaChannels {
      DMA0_SLOT_Disabled                            = 0,
      DMA0_SLOT_UART0_Receive                       = 2,
      DMA0_SLOT_UART0_Transmit                      = 3,
      DMA0_SLOT_UART1_Receive                       = 4,
      DMA0_SLOT_UART1_Transmit                      = 5,
      DMA0_SLOT_UART2_Receive                       = 6,
      DMA0_SLOT_UART2_Transmit                      = 7,
      DMA0_SLOT_I2S0_Receive                        = 12,
      DMA0_SLOT_I2S0_Transmit                       = 13,
      DMA0_SLOT_SPI0_Receive                        = 14,
      DMA0_SLOT_SPI0_Transmit                       = 15,
      DMA0_SLOT_SPI0_TransmitReceive                = 16,
      DMA0_SLOT_I2C0                                = 18,
      DMA0_SLOT_I2C1                                = 19,
      DMA0_SLOT_FTM0_Ch_0                           = 20,
      DMA0_SLOT_FTM0_Ch_1                           = 21,
      DMA0_SLOT_FTM0_Ch_2                           = 22,
      DMA0_SLOT_FTM0_Ch_3                           = 23,
      DMA0_SLOT_FTM0_Ch_4                           = 24,
      DMA0_SLOT_FTM0_Ch_5                           = 25,
      DMA0_SLOT_FTM0_Ch_6                           = 26,
      DMA0_SLOT_FTM0_Ch_7                           = 27,
      DMA0_SLOT_FTM1_Ch_0                           = 28,
      DMA0_SLOT_FTM1_Ch_1                           = 29,
      DMA0_SLOT_FTM2_Ch_0                           = 30,
      DMA0_SLOT_FTM2_Ch_1                           = 31,
      DMA0_SLOT_FTM3_Ch_0                           = 32,
      DMA0_SLOT_FTM3_Ch_1                           = 33,
      DMA0_SLOT_FTM3_Ch_2                           = 34,
      DMA0_SLOT_FTM3_Ch_3                           = 35,
      DMA0_SLOT_FTM3_Ch_4                           = 36,
      DMA0_SLOT_FTM3_Ch_5                           = 37,
      DMA0_SLOT_FTM3_Ch_6                           = 38,
      DMA0_SLOT_FTM3_Ch_7                           = 39,
      DMA0_SLOT_ADC0                                = 40,
      DMA0_SLOT_ADC1                                = 41,
      DMA0_SLOT_CMP0                                = 42,
      DMA0_SLOT_CMP1                                = 43,
      DMA0_SLOT_DAC0                                = 45,
      DMA0_SLOT_DAC1                                = 46,
      DMA0_SLOT_PDB                                 = 48,
      DMA0_SLOT_PortA                               = 49,
      DMA0_SLOT_PortB                               = 50,
      DMA0_SLOT_PortC                               = 51,
      DMA0_SLOT_PortD                               = 52,
      DMA0_SLOT_PortE                               = 53,
      DMA0_SLOT_LPUART_Receive                      = 58,
      DMA0_SLOT_LPUART_Transmit                     = 59,
      DMA0_SLOT_AlwaysEnabled0                      = 60,
      DMA0_SLOT_AlwaysEnabled1                      = 61,
      DMA0_SLOT_AlwaysEnabled2                      = 62,
      DMA0_SLOT_AlwaysEnabled3                      = 63,
   };
};

/** 
 * End DMAMUX_Group
 * @}
 */
/**
 * @addtogroup EWM_Group EWM, External Watchdog Monitor
 * @brief Pins used for External Watchdog Monitor
 * @{
 */
#define USBDM_EWM_IS_DEFINED 
/**
 * Peripheral information for EWM, External Watchdog Monitor
 */
class EwmInfo {
public:
   //! Hardware base pointer
   static constexpr volatile EWM_Type *ewm   = (volatile EWM_Type *)EWM_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_EWM_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: EWM_IN               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: EWM_OUT_b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End EWM_Group
 * @}
 */
/**
 * @addtogroup FB_Group FB, Flexbus
 * @brief Pins used for Flexbus
 * @{
 */
#define USBDM_FB_IS_DEFINED  
/**
 * Peripheral information for FB, Flexbus
 */
class FbInfo {
public:
   //! Hardware base pointer
   static constexpr volatile FB_Type *fb   = (volatile FB_Type *)FB_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC7_FLEXBUS_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC7));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 82;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FB_CS0_b             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FB_CS1_b             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: FB_CS2_b             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: FB_CS3_b             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: FB_CS4_b             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: FB_CS5_b             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: FB_AD0               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: FB_AD1               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: FB_AD2               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: FB_AD3               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: FB_AD4               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  11: FB_AD5               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  12: FB_AD6               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  13: FB_AD7               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  14: FB_AD8               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: FB_AD9               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  16: FB_AD10              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  17: FB_AD11              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  18: FB_AD12              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  19: FB_AD13              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  20: FB_AD14              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  21: FB_AD15              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  22: FB_AD16              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  23: FB_AD17              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  24: FB_AD18              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  25: FB_AD19              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  26: FB_AD20              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  27: FB_AD21              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  28: FB_AD22              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  29: FB_AD23              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  30: FB_AD24              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  31: FB_AD25              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  32: FB_AD26              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  33: FB_AD27              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  34: FB_AD28              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  35: FB_AD29              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  36: FB_AD30              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  37: FB_AD31              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  38: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  39: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  40: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  41: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  42: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  43: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  44: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  45: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  46: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  47: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  48: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  49: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  50: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  51: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  52: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  53: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  54: FB_A16               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  55: FB_A17               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  56: FB_A18               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  57: FB_A19               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  58: FB_A20               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  59: FB_A21               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  60: FB_A22               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  61: FB_A23               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  62: FB_A24               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  63: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  64: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  65: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  66: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  67: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  68: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  69: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  70: FB_TSIZ0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  71: FB_TSIZ1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  72: FB_ALE               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  73: FB_OE_b              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  74: FB_RW_b              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  75: FB_TA_b              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  76: FB_TBST_b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  77: FB_TS_b              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  78: FB_BE7_0_BLS31_24_b  = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  79: FB_BE15_8_BLS23_16_b = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  80: FB_BE23_16_BLS15_8_b = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  81: FB_BE31_24_BLS7_0_b  = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End FB_Group
 * @}
 */
/**
 * @addtogroup FTFA_TODO_Group FTFA, (Incomplete)
 * @brief Pins used for (Incomplete)
 * @{
 */
#define USBDM_FTFA_IS_DEFINED 
/**
 * Peripheral information for FTFA, (Incomplete)
 */
class FtfaInfo {
public:
   //! Hardware base pointer
   static constexpr volatile FTFA_Type *ftfa   = (volatile FTFA_Type *)FTFA_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTF_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

};

/** 
 * End FTFA_TODO_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, Shared Resources
 * @brief Pins used for Shared Resources
 * @{
 */
#define USBDM_FTM_IS_DEFINED 
/**
 * Peripheral information for FTM, Shared Resources
 */
class FtmInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM_CLKIN0           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM_CLKIN1           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_FTM0_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm0Info {
public:
   //! Hardware base pointer
   static constexpr volatile FTM_Type *ftm   = (volatile FTM_Type *)FTM0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM0_IRQn};

   // Template:ftm0_8ch_icrst

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Period
   static constexpr uint32_t period = 10000;

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_TOIE(false)| // Timer Overflow Interrupt Enable
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      switch(ftm->SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      float freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      uint32_t freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM0_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM0_CH1             = PTC2 (A3/J24_8)                */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  2,   PORT_PCR_MUX(4)|pcrValue  },
         /*   2: FTM0_CH2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: FTM0_CH3             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: FTM0_CH4             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: FTM0_CH5             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: FTM0_CH6             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: FTM0_CH7             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Ftm0Info,  1>::setPCR(); // FTM0_CH1        = PTC2 (A3/J24_8)               
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Ftm0Info,  1>::setPCR(0); // FTM0_CH1        = PTC2 (A3/J24_8)               
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM0_FLT0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM0_FLT1            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   2: FTM0_FLT2            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   3: FTM0_FLT3            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM1_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm1Info {
public:
   //! Hardware base pointer
   static constexpr volatile FTM_Type *ftm   = (volatile FTM_Type *)FTM1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM1_IRQn};

   // Template:ftm1_2ch_icrst

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Period
   static constexpr uint32_t period = 10000;

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_TOIE(false)| // Timer Overflow Interrupt Enable
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      switch(ftm->SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      float freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      uint32_t freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM1_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM1_CH1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 1;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM1_FLT0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 2;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM1_QD_PHA          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM1_QD_PHB          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM2_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm2Info {
public:
   //! Hardware base pointer
   static constexpr volatile FTM_Type *ftm   = (volatile FTM_Type *)FTM2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM2_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM2_IRQn};

   // Template:ftm1_2ch_icrst

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Period
   static constexpr uint32_t period = 10000;

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_TOIE(false)| // Timer Overflow Interrupt Enable
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      switch(ftm->SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      float freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      uint32_t freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM2_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM2_CH1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 1;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM2_FLT0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 2;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM2_QD_PHA          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM2_QD_PHB          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM3_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm3Info {
public:
   //! Hardware base pointer
   static constexpr volatile FTM_Type *ftm   = (volatile FTM_Type *)FTM3_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:ftm0_8ch_icrst

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Period
   static constexpr uint32_t period = 10000;

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_TOIE(false)| // Timer Overflow Interrupt Enable
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      switch(ftm->SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      float freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile FTM_Type *ftm = reinterpret_cast<volatile FTM_Type *>(basePtr);
   
      uint32_t freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM3_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM3_CH1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: FTM3_CH2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: FTM3_CH3             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: FTM3_CH4             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: FTM3_CH5             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: FTM3_CH6             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: FTM3_CH7             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 1;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM3_FLT0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End FTM_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Pins used for Digital Input/Output
 * @{
 */
#define USBDM_GPIOA_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioAInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTA_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOA_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTA_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTA_IRQn};

};

#define USBDM_GPIOB_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioBInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTB_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOB_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTB_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTB_IRQn};

};

#define USBDM_GPIOC_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioCInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTC_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOC_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTC_IRQn};

};

#define USBDM_GPIOD_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioDInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTD_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOD_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTD_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTD_IRQn};

};

#define USBDM_GPIOE_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioEInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTE_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOE_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTE_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTE_IRQn};

};

/** 
 * End GPIO_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Pins used for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2C0_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface
 */
class I2c0Info {
public:
   //! Hardware base pointer
   static constexpr volatile I2C_Type *i2c   = (volatile I2C_Type *)I2C0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_I2C0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C0_IRQn};

   // Template:i2c0_f12

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C0_SCL             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2C0_SDA             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_I2C1_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface
 */
class I2c1Info {
public:
   //! Hardware base pointer
   static constexpr volatile I2C_Type *i2c   = (volatile I2C_Type *)I2C1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_I2C1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C1_IRQn};

   // Template:i2c0_f12

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C1_SCL             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2C1_SDA             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End I2C_Group
 * @}
 */
/**
 * @addtogroup I2S_Group I2S, Inter-Integrated-Circuit Interface
 * @brief Pins used for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2S0_IS_DEFINED 
/**
 * Peripheral information for I2S, Inter-Integrated-Circuit Interface
 */
class I2s0Info {
public:
   //! Hardware base pointer
   static constexpr volatile I2S_Type *i2s   = (volatile I2S_Type *)I2S0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_I2S_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2S0_Tx_IRQn, I2S0_Rx_IRQn};

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2S0_MCLK            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2S0_RX_BCLK         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: I2S0_RX_FS           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: I2S0_TX_BCLK         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: I2S0_TX_FS           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: I2S0_TXD0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: I2S0_RXD0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End I2S_Group
 * @}
 */
/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Pins used for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_LLWU_IS_DEFINED 
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit
 */
class LlwuInfo {
public:
   //! Hardware base pointer
   static constexpr volatile LLWU_Type *llwu   = (volatile LLWU_Type *)LLWU_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: LLWU_P0              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: LLWU_P1              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: LLWU_P2              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: LLWU_P3              = PTA4 (D4/J1_10)                */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  4,   PORT_PCR_MUX(1)|pcrValue  },
         /*   4: LLWU_P4              = PTA13 (D17/J1_3)               */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  13,  PORT_PCR_MUX(1)|pcrValue  },
         /*   5: LLWU_P5              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: LLWU_P6              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: LLWU_P7              = PTC3 (D6/J1_14)                */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  3,   PORT_PCR_MUX(1)|pcrValue  },
         /*   8: LLWU_P8              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: LLWU_P9              = PTC5 (D23/J1_15)               */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  5,   PORT_PCR_MUX(1)|pcrValue  },
         /*  10: LLWU_P10             = PTC6 (D7/J1_16)                */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  6,   PORT_PCR_MUX(1)|pcrValue  },
         /*  11: LLWU_P11             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  12: LLWU_P12             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  13: LLWU_P13             = PTD2 (D0/J1_2/SD_MOSI/BT_RX)   */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  2,   PORT_PCR_MUX(1)|pcrValue  },
         /*  14: LLWU_P14             = PTD4 (D10/J2_6)                */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  4,   PORT_PCR_MUX(1)|pcrValue  },
         /*  15: LLWU_P15             = PTD6 (D11/J2_8)                */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  6,   PORT_PCR_MUX(1)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<LlwuInfo,  3>::setPCR(); // LLWU_P3         = PTA4 (D4/J1_10)               
      PcrTable_T<LlwuInfo,  4>::setPCR(); // LLWU_P4         = PTA13 (D17/J1_3)              
      PcrTable_T<LlwuInfo,  7>::setPCR(); // LLWU_P7         = PTC3 (D6/J1_14)               
      PcrTable_T<LlwuInfo,  9>::setPCR(); // LLWU_P9         = PTC5 (D23/J1_15)              
      PcrTable_T<LlwuInfo, 10>::setPCR(); // LLWU_P10        = PTC6 (D7/J1_16)               
      PcrTable_T<LlwuInfo, 13>::setPCR(); // LLWU_P13        = PTD2 (D0/J1_2/SD_MOSI/BT_RX)  
      PcrTable_T<LlwuInfo, 14>::setPCR(); // LLWU_P14        = PTD4 (D10/J2_6)               
      PcrTable_T<LlwuInfo, 15>::setPCR(); // LLWU_P15        = PTD6 (D11/J2_8)               
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<LlwuInfo,  3>::setPCR(0); // LLWU_P3         = PTA4 (D4/J1_10)               
      PcrTable_T<LlwuInfo,  4>::setPCR(0); // LLWU_P4         = PTA13 (D17/J1_3)              
      PcrTable_T<LlwuInfo,  7>::setPCR(0); // LLWU_P7         = PTC3 (D6/J1_14)               
      PcrTable_T<LlwuInfo,  9>::setPCR(0); // LLWU_P9         = PTC5 (D23/J1_15)              
      PcrTable_T<LlwuInfo, 10>::setPCR(0); // LLWU_P10        = PTC6 (D7/J1_16)               
      PcrTable_T<LlwuInfo, 13>::setPCR(0); // LLWU_P13        = PTD2 (D0/J1_2/SD_MOSI/BT_RX)  
      PcrTable_T<LlwuInfo, 14>::setPCR(0); // LLWU_P14        = PTD4 (D10/J2_6)               
      PcrTable_T<LlwuInfo, 15>::setPCR(0); // LLWU_P15        = PTD6 (D11/J2_8)               
   }

};

/** 
 * End LLWU_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Pins used for Low Power Timer
 * @{
 */
#define USBDM_LPTMR0_IS_DEFINED 
/**
 * Peripheral information for LPTMR, Low Power Timer
 */
class Lptmr0Info {
public:
   //! Hardware base pointer
   static constexpr volatile LPTMR_Type *lptmr   = (volatile LPTMR_Type *)LPTMR0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_LPTMR_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC5));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LPTMR0_IRQn};

   // Template:lptmr0_0

   //! Default Timer Compare value
   static constexpr uint32_t cmr = 0;

   //! Default PSR value
   static constexpr uint32_t psr = 
      LPTMR_PSR_PRESCALE(0)|
      LPTMR_PSR_PBYP(0)|
      LPTMR_PSR_PCS(0);

   //! Default CSR value
   static constexpr uint32_t csr = 
      LPTMR_CSR_TIE(false)|
      LPTMR_CSR_TMS(0)|
      LPTMR_CSR_TFC(0)|
      LPTMR_CSR_TPP(0)|
      LPTMR_CSR_TPS(0);

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile LPTMR_Type *lptmr = reinterpret_cast<volatile LPTMR_Type *>(basePtr);
   
      switch(lptmr->PSR&LPTMR_PSR_PCS_MASK) {
      default:
      case LPTMR_PSR_PCS(0): return SystemMcgirClock;
      case LPTMR_PSR_PCS(1): return SystemLpoClock;
      case LPTMR_PSR_PCS(2): return SystemErclk32kClock;
      case LPTMR_PSR_PCS(3): return SystemOscerClock;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
      /** Pointer to hardware */
      static constexpr volatile LPTMR_Type *lptmr = reinterpret_cast<volatile LPTMR_Type *>(basePtr);
   
      float freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
      /** Pointer to hardware */
      static constexpr volatile LPTMR_Type *lptmr = reinterpret_cast<volatile LPTMR_Type *>(basePtr);
   
      uint32_t freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: LPTMR0_ALT1          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: LPTMR0_ALT2          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End LPTMR_Group
 * @}
 */
/**
 * @addtogroup LPUART_Group LPUART, Low Power Universal Asynchronous Receiver/Transmitter
 * @brief Pins used for Low Power Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_LPUART0_IS_DEFINED 
/**
 * Peripheral information for LPUART, Low Power Universal Asynchronous Receiver/Transmitter
 */
class Lpuart0Info {
public:
   //! Hardware base pointer
   static constexpr volatile LPUART_Type *lpuart   = (volatile LPUART_Type *)LPUART0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_LPUART0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LPUART0_RX_TX_IRQn};

   // Template:lpuart0_0x4002a000

   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
      return SimInfo::getLpuartClockFrequency();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: LPUART0_TX           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: LPUART0_RX           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: LPUART0_RTS_b        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: LPUART0_CTS_b        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End LPUART_Group
 * @}
 */
/**
 * @addtogroup PDB_Group PDB, Programmable Dely Block
 * @brief Pins used for Programmable Dely Block
 * @{
 */
#define USBDM_PDB0_IS_DEFINED 
/**
 * Peripheral information for PDB, Programmable Dely Block
 */
class Pdb0Info {
public:
   //! Hardware base pointer
   static constexpr volatile PDB_Type *pdb   = (volatile PDB_Type *)PDB0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_PDB_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PDB0_IRQn};

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: PDB0_EXTRG           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End PDB_Group
 * @}
 */
/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Pins used for Programmable Interrupt Timer
 * @{
 */
#define USBDM_PIT_IS_DEFINED 
/**
 * Peripheral information for PIT, Programmable Interrupt Timer
 */
class PitInfo {
public:
   //! Hardware base pointer
   static constexpr volatile PIT_Type *pit   = (volatile PIT_Type *)PIT_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_PIT_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 4;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PIT0_IRQn, PIT1_IRQn, PIT2_IRQn, PIT3_IRQn};

   // Template:pit_4ch_chain

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Default value for PIT->SC register
   static constexpr uint32_t loadValue  = 
      10000;

   //! PIT operation in debug mode
   static constexpr uint32_t mcr = 
      PIT_MCR_FRZ(0);

};

/** 
 * End PIT_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Pins used for Power
 * @{
 */
#define USBDM_POWER_IS_DEFINED 
/**
 * Peripheral information for POWER, Power
 */
class PowerInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 22;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VBAT                 = VBAT (VBAT)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: VDD1                 = VDD1 (VDD)                     */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: VDD2                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: VDD3                 = VDD3 (VDD)                     */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: VDD4                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: VDD                  = VDD5 (VDD5)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: VDD6                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: VDD7                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: VDDA                 = VDDA (VDDA)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   9: VOUT33               = VOUT33 (VOUT33)                */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  10: VREFH                = VREFH (VREFH)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  11: VREFL                = VREFL (VREFL)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  12: VREGIN               = VREGIN (VREGIN)                */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  13: VSS1                 = VSS1 (VSS)                     */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  14: VSS1a                = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: VSS2                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  16: VSS3                 = VSS3 (VSS)                     */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  17: VSS4                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  18: VSS                  = VSS5 (VSS5)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  19: VSS6                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  20: VSS7                 = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  21: VSSA                 = VSSA (VSSA)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End Power_Group
 * @}
 */
/**
 * @addtogroup RNG_TODO_Group RNG, (Incomplete)
 * @brief Pins used for (Incomplete)
 * @{
 */
#define USBDM_RNG_IS_DEFINED 
/**
 * Peripheral information for RNG, (Incomplete)
 */
class RngInfo {
public:
   //! Hardware base pointer
   static constexpr volatile RNG_Type *rng   = (volatile RNG_Type *)RNG_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_RNGA_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {RNG_IRQn};

};

/** 
 * End RNG_TODO_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Pins used for Serial Peripheral Interface
 * @{
 */
#define USBDM_SPI0_IS_DEFINED 
/**
 * Peripheral information for SPI, Serial Peripheral Interface
 */
class Spi0Info {
public:
   //! Hardware base pointer
   static constexpr volatile SPI_Type *spi   = (volatile SPI_Type *)SPI0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_SPI0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {SPI0_IRQn};

   // Template:spi0_mk_pcsis6_pcsse

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

#ifdef SPI_CTAR_LSBFE_SHIFT
   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint32_t modeValue = 
      SPI_CTAR_LSBFE(0)| // LSB or MSB first
      SPI_CTAR_MODE(0);  // Mode (CPOL+CPHA)

#endif

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed = 
      100000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SPI0_SCK             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: SPI0_SIN             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: SPI0_SOUT            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: SPI0_PCS0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: SPI0_PCS1            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: SPI0_PCS2            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: SPI0_PCS3            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: SPI0_PCS4            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: SPI0_PCS5            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_SPI1_IS_DEFINED 
/**
 * Peripheral information for SPI, Serial Peripheral Interface
 */
class Spi1Info {
public:
   //! Hardware base pointer
   static constexpr volatile SPI_Type *spi   = (volatile SPI_Type *)SPI1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_SPI1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {SPI1_IRQn};

   // Template:spi1_mk_fifo_depth1

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

#ifdef SPI_CTAR_LSBFE_SHIFT
   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint32_t modeValue = 
      SPI_CTAR_LSBFE(0)| // LSB or MSB first
      SPI_CTAR_MODE(1);  // Mode (CPOL+CPHA)

#endif

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed = 
      10000000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 7;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SPI1_SCK             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: SPI1_SIN             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: SPI1_SOUT            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: SPI1_PCS0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: SPI1_PCS1            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: SPI1_PCS2            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: SPI1_PCS3            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End SPI_Group
 * @}
 */
/**
 * @addtogroup UART_Group UART, Universal Asynchronous Receiver/Transmitter
 * @brief Pins used for Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_UART0_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart0Info {
public:
   //! Hardware base pointer
   static constexpr volatile UART_Type *uart   = (volatile UART_Type *)UART0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART0_RX_TX_IRQn, UART0_ERR_IRQn};

   // Template:uart0_mk21fa12_c7816

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   static constexpr bool statusNeedsWrite = false;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemCoreClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART0_TX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART0_RX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: UART0_RTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART0_CTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_UART1_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart1Info {
public:
   //! Hardware base pointer
   static constexpr volatile UART_Type *uart   = (volatile UART_Type *)UART1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART1_RX_TX_IRQn, UART1_ERR_IRQn};

   // Template:uart1_mk10d10

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   static constexpr bool statusNeedsWrite = false;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemCoreClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART1_TX             = PTE0 (D14/J2_18/ConTx)         */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  0,   PORT_PCR_MUX(3)|pcrValue  },
         /*   1: UART1_RX             = PTE1 (D15/J2_19/ConRx)         */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  1,   PORT_PCR_MUX(3)|pcrValue  },
         /*   2: UART1_RTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART1_CTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Uart1Info,  0>::setPCR(); // UART1_TX        = PTE0 (D14/J2_18/ConTx)        
      PcrTable_T<Uart1Info,  1>::setPCR(); // UART1_RX        = PTE1 (D15/J2_19/ConRx)        
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Uart1Info,  0>::setPCR(0); // UART1_TX        = PTE0 (D14/J2_18/ConTx)        
      PcrTable_T<Uart1Info,  1>::setPCR(0); // UART1_RX        = PTE1 (D15/J2_19/ConRx)        
   }

};

#define USBDM_UART2_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart2Info {
public:
   //! Hardware base pointer
   static constexpr volatile UART_Type *uart   = (volatile UART_Type *)UART2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART2_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART2_RX_TX_IRQn, UART2_ERR_IRQn};

   // Template:uart1_mk10d10

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   static constexpr bool statusNeedsWrite = false;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART2_TX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART2_RX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: UART2_RTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART2_CTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End UART_Group
 * @}
 */
/**
 * @addtogroup USB_Group USB, USB OTG Controller
 * @brief Pins used for USB OTG Controller
 * @{
 */
#define USBDM_USB0_IS_DEFINED 
/**
 * Peripheral information for USB, USB OTG Controller
 */
class Usb0Info {
public:
   //! Hardware base pointer
   static constexpr volatile USB_Type *usb   = (volatile USB_Type *)USB0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_USBOTG_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {USB0_IRQn};

   // Template:usb0_otg_clkrcv_c

   //! Install Callback handler
   static constexpr bool irqEnabled = false;

   //! Install Callback handler
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: USB0_DM              = USB0_DM (USB0_DM)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: USB0_DP              = USB0_DP (USB0_DP)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: USB_CLKIN            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: USB_SOF_OUT          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End USB_Group
 * @}
 */
/**
 * @addtogroup VREF_Group VREF, Voltage Reference
 * @brief Pins used for Voltage Reference
 * @{
 */
#define USBDM_VREF_IS_DEFINED 
/**
 * Peripheral information for VREF, Voltage Reference
 */
class VrefInfo {
public:
   //! Hardware base pointer
   static constexpr volatile VREF_Type *vref   = (volatile VREF_Type *)VREF_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_VREF_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VREF_OUT             = VREF_OUT (D24)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End VREF_Group
 * @}
 */

} // End namespace USBDM

#include "adc.h"
#include "ftm.h"
#include "gpio.h"

namespace USBDM {

/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Pins used for Analogue Input
 * @{
 */
using adc_A7               = const USBDM::Adc0Channel<0>;
using adc_J24_3            = const USBDM::Adc0Channel<0>;
//using adc_A7               = const USBDM::Adc0Channel<19>;
//using adc_J24_3            = const USBDM::Adc0Channel<19>;
using adc_A6               = const USBDM::Adc0Channel<0>;
using adc_J24_1            = const USBDM::Adc0Channel<0>;
//using adc_A6               = const USBDM::Adc0Channel<0>;
//using adc_J24_1            = const USBDM::Adc0Channel<0>;
using adc_A9               = const USBDM::Adc0Channel<3>;
using adc_J24_7            = const USBDM::Adc0Channel<3>;
using adc_A8               = const USBDM::Adc0Channel<3>;
using adc_J24_5            = const USBDM::Adc0Channel<3>;
//using adc_A8               = const USBDM::Adc0Channel<3>;
//using adc_J24_5            = const USBDM::Adc0Channel<3>;
using adc_A11              = const USBDM::Adc0Channel<23>;
using adc_J24_11           = const USBDM::Adc0Channel<23>;
using adc_A0               = const USBDM::Adc0Channel<8>;
using adc_J24_2            = const USBDM::Adc0Channel<8>;
using adc_A1               = const USBDM::Adc0Channel<9>;
using adc_J24_4            = const USBDM::Adc0Channel<9>;
using adc_A5               = const USBDM::Adc0Channel<12>;
using adc_J24_12           = const USBDM::Adc0Channel<12>;
using adc_ONBOARD_SCL      = const USBDM::Adc0Channel<12>;
using adc_A4               = const USBDM::Adc0Channel<13>;
using adc_J24_10           = const USBDM::Adc0Channel<13>;
using adc_ONBOARD_SDA      = const USBDM::Adc0Channel<13>;
using adc_A2               = const USBDM::Adc0Channel<15>;
using adc_J24_6            = const USBDM::Adc0Channel<15>;
using adc_SW2              = const USBDM::Adc0Channel<15>;
//using adc_A7               = const USBDM::Adc1Channel<3>;
//using adc_J24_3            = const USBDM::Adc1Channel<3>;
//using adc_A6               = const USBDM::Adc1Channel<3>;
//using adc_J24_1            = const USBDM::Adc1Channel<3>;
//using adc_A9               = const USBDM::Adc1Channel<0>;
//using adc_J24_7            = const USBDM::Adc1Channel<0>;
//using adc_A9               = const USBDM::Adc1Channel<19>;
//using adc_J24_7            = const USBDM::Adc1Channel<19>;
//using adc_A8               = const USBDM::Adc1Channel<0>;
//using adc_J24_5            = const USBDM::Adc1Channel<0>;
//using adc_A8               = const USBDM::Adc1Channel<0>;
//using adc_J24_5            = const USBDM::Adc1Channel<0>;
//using adc_A0               = const USBDM::Adc1Channel<8>;
//using adc_J24_2            = const USBDM::Adc1Channel<8>;
//using adc_A1               = const USBDM::Adc1Channel<9>;
//using adc_J24_4            = const USBDM::Adc1Channel<9>;
using adc_D24              = const USBDM::Adc1Channel<18>;
/** 
 * End ADC_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */
using ftm_A3               = const USBDM::Ftm0Channel<1>;
using ftm_J24_8            = const USBDM::Ftm0Channel<1>;
/** 
 * End FTM_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Pins used for Digital Input/Output
 * @{
 */
using gpio_D9              = const USBDM::GpioA<1>;
using gpio_J2_4            = const USBDM::GpioA<1>;
using gpio_LED_RED         = const USBDM::GpioA<1>;
using gpio_D3              = const USBDM::GpioA<2>;
using gpio_J1_8            = const USBDM::GpioA<2>;
using gpio_LED_GREEN       = const USBDM::GpioA<2>;
using gpio_D4              = const USBDM::GpioA<4>;
using gpio_J1_10           = const USBDM::GpioA<4>;
using gpio_D16             = const USBDM::GpioA<5>;
using gpio_J1_1            = const USBDM::GpioA<5>;
using gpio_D18             = const USBDM::GpioA<12>;
using gpio_J1_5            = const USBDM::GpioA<12>;
using gpio_D17             = const USBDM::GpioA<13>;
using gpio_J1_3            = const USBDM::GpioA<13>;
using gpio_D2              = const USBDM::GpioB<16>;
using gpio_J1_6            = const USBDM::GpioB<16>;
using gpio_SD_DETECT       = const USBDM::GpioB<16>;
using gpio_SW3             = const USBDM::GpioB<17>;
using gpio_D5              = const USBDM::GpioB<18>;
using gpio_J1_12           = const USBDM::GpioB<18>;
using gpio_D8              = const USBDM::GpioB<19>;
using gpio_J2_2            = const USBDM::GpioB<19>;
using gpio_D6              = const USBDM::GpioC<3>;
using gpio_J1_14           = const USBDM::GpioC<3>;
using gpio_D23             = const USBDM::GpioC<5>;
using gpio_J1_15           = const USBDM::GpioC<5>;
using gpio_D7              = const USBDM::GpioC<6>;
using gpio_J1_16           = const USBDM::GpioC<6>;
using gpio_D21             = const USBDM::GpioC<7>;
using gpio_J1_11           = const USBDM::GpioC<7>;
using gpio_D19             = const USBDM::GpioC<8>;
using gpio_J1_7            = const USBDM::GpioC<8>;
using gpio_D20             = const USBDM::GpioC<9>;
using gpio_J1_9            = const USBDM::GpioC<9>;
using gpio_D22             = const USBDM::GpioC<10>;
using gpio_J1_13           = const USBDM::GpioC<10>;
using gpio_D0              = const USBDM::GpioD<2>;
using gpio_J1_2            = const USBDM::GpioD<2>;
using gpio_SD_MOSI         = const USBDM::GpioD<2>;
using gpio_BT_RX           = const USBDM::GpioD<2>;
using gpio_D1              = const USBDM::GpioD<3>;
using gpio_J1_4            = const USBDM::GpioD<3>;
using gpio_SD_MISO         = const USBDM::GpioD<3>;
using gpio_BT_TX           = const USBDM::GpioD<3>;
using gpio_D10             = const USBDM::GpioD<4>;
using gpio_J2_6            = const USBDM::GpioD<4>;
using gpio_D13             = const USBDM::GpioD<5>;
using gpio_J2_12           = const USBDM::GpioD<5>;
using gpio_LED_BLUE        = const USBDM::GpioD<5>;
using gpio_D11             = const USBDM::GpioD<6>;
using gpio_J2_8            = const USBDM::GpioD<6>;
using gpio_D12             = const USBDM::GpioD<7>;
using gpio_J2_10           = const USBDM::GpioD<7>;
/** 
 * End GPIO_Group
 * @}
 */
/**
 * Used to configure pin-mapping before 1st use of peripherals
 */
extern void mapAllPins();

} // End namespace USBDM
/**
 *
 * @mainpage Summary
 *
 * @section PinsByPinName Pins by Pin Name
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  ADC0_DM0                 | ADC0_DM0/ADC1_DM3/ADC0_SE19                 | A7/J24_3                  | -       
 *  ADC0_DP0                 | ADC0_DP0/ADC1_DP3/ADC0_SE0                  | A6/J24_1                  | -       
 *  ADC1_DM0                 | ADC1_DM0/ADC0_DM3/ADC1_SE19                 | A9/J24_7                  | -       
 *  ADC1_DP0                 | ADC1_DP0/ADC0_DP3/ADC1_SE0/ADC0_SE3         | A8/J24_5                  | -       
 *  DAC0_OUT                 | DAC0_OUT/CMP1_IN3/ADC0_SE23                 | A11/J24_11                | -       
 *  EXTAL32                  | EXTAL32                                     | EXTAL32                   | Reserved(Crystal)       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | SWD_CLK                   | Reserved(SWD)       
 *  PTA1                     | GPIOA_1                                     | D9/J2_4/LED_RED           | Red LED       
 *  PTA2                     | GPIOA_2                                     | D3/J1_8/LED_GREEN         | Green LED       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | SWD_DIO                   | Reserved(SWD)       
 *  PTA4                     | GPIOA_4/LLWU_P3                             | D4/J1_10                  | -       
 *  PTA5                     | GPIOA_5                                     | D16/J1_1                  | -       
 *  PTA12                    | GPIOA_12                                    | D18/J1_5                  | -       
 *  PTA13                    | GPIOA_13/LLWU_P4                            | D17/J1_3                  | -       
 *  PTA18                    | EXTAL0                                      | EXTAL0                    | Reserved(Crystal)       
 *  PTA19                    | XTAL0                                       | XTAL0                     | Reserved(Crystal)       
 *  PTB0                     | ADC0_SE8/ADC1_SE8                           | A0/J24_2                  | -       
 *  PTB1                     | ADC0_SE9/ADC1_SE9                           | A1/J24_4                  | -       
 *  PTB2                     | ADC0_SE12                                   | A5/J24_12/ONBOARD_SCL     | Accelerometer, Magnetometer_scl       
 *  PTB3                     | ADC0_SE13                                   | A4/J24_10/ONBOARD_SDA     | Accelerometer, Magnetometer_sda       
 *  PTB16                    | GPIOB_16                                    | D2/J1_6/SD_DETECT         | -       
 *  PTB17                    | GPIOB_17                                    | SW3                       | SW3       
 *  PTB18                    | GPIOB_18                                    | D5/J1_12                  | -       
 *  PTB19                    | GPIOB_19                                    | D8/J2_2                   | -       
 *  PTC0                     | ADC0_SE14                                   | USB_FLAG                  | -       
 *  PTC1                     | ADC0_SE15                                   | A2/J24_6/SW2              | SW2       
 *  PTC2                     | FTM0_CH1                                    | A3/J24_8                  | -       
 *  PTC3                     | GPIOC_3/LLWU_P7                             | D6/J1_14                  | -       
 *  PTC4                     | Disabled                                    | A10/J24_9/SD_SS           | -       
 *  PTC5                     | GPIOC_5/LLWU_P9                             | D23/J1_15                 | -       
 *  PTC6                     | GPIOC_6/LLWU_P10                            | D7/J1_16                  | -       
 *  PTC7                     | GPIOC_7                                     | D21/J1_11                 | -       
 *  PTC8                     | GPIOC_8                                     | D19/J1_7                  | -       
 *  PTC9                     | GPIOC_9                                     | D20/J1_9                  | -       
 *  PTC10                    | GPIOC_10                                    | D22/J1_13                 | -       
 *  PTC11                    | ADC1_SE7b                                   |                           | RF_ce*       
 *  PTD0                     | Disabled                                    |                           | Accelerometer, Magnetometer & RF IRQ       
 *  PTD1                     | ADC0_SE5b                                   | SD_CLK                    | RF_sck       
 *  PTD2                     | GPIOD_2/LLWU_P13                            | D0/J1_2/SD_MOSI/BT_RX     | RF_mosi, Bluetooth_tx       
 *  PTD3                     | GPIOD_3                                     | D1/J1_4/SD_MISO/BT_TX     | RF_miso, Bluetooth_rx       
 *  PTD4                     | GPIOD_4/LLWU_P14                            | D10/J2_6                  | RF_cs*       
 *  PTD5                     | GPIOD_5                                     | D13/J2_12/LED_BLUE        | Blue LED       
 *  PTD6                     | GPIOD_6/LLWU_P15                            | D11/J2_8                  | -       
 *  PTD7                     | GPIOD_7                                     | D12/J2_10                 | -       
 *  PTE0                     | UART1_TX                                    | D14/J2_18/ConTx           | USB Serial Tx       
 *  PTE1                     | UART1_RX                                    | D15/J2_19/ConRx           | USB Serial Rx       
 *  RESET_b                  | RESET_b                                     | RESET_b                   | Reserved(Reset*)       
 *  USB0_DM                  | USB0_DM                                     | USB0_DM                   | Reserved(USB_DM)       
 *  USB0_DP                  | USB0_DP                                     | USB0_DP                   | Reserved(USB_DP)       
 *  VBAT                     | VBAT                                        | VBAT                      | -       
 *  VDD1                     | VDD1                                        | VDD                       | -       
 *  VDD3                     | VDD3                                        | VDD                       | -       
 *  VDD5                     | VDD                                         | VDD5                      | -       
 *  VDDA                     | VDDA                                        | VDDA                      | -       
 *  VOUT33                   | VOUT33                                      | VOUT33                    | -       
 *  VREFH                    | VREFH                                       | VREFH                     | -       
 *  VREFL                    | VREFL                                       | VREFL                     | -       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5/ADC1_SE18        | D24                       | -       
 *  VREGIN                   | VREGIN                                      | VREGIN                    | -       
 *  VSS1                     | VSS1                                        | VSS                       | -       
 *  VSS3                     | VSS3                                        | VSS                       | -       
 *  VSS5                     | VSS                                         | VSS5                      | -       
 *  VSSA                     | VSSA                                        | VSSA                      | -       
 *  XTAL32                   | XTAL32                                      | XTAL32                    | Reserved(Crystal)       
 *
 *
 * @section PinsByLocation Pins by Location
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTB0                     | ADC0_SE8/ADC1_SE8                           | A0/J24_2                  | -       
 *  PTB1                     | ADC0_SE9/ADC1_SE9                           | A1/J24_4                  | -       
 *  PTC1                     | ADC0_SE15                                   | A2/J24_6/SW2              | SW2       
 *  PTC2                     | FTM0_CH1                                    | A3/J24_8                  | -       
 *  PTB3                     | ADC0_SE13                                   | A4/J24_10/ONBOARD_SDA     | Accelerometer, Magnetometer_sda       
 *  PTB2                     | ADC0_SE12                                   | A5/J24_12/ONBOARD_SCL     | Accelerometer, Magnetometer_scl       
 *  ADC0_DP0                 | ADC0_DP0/ADC1_DP3/ADC0_SE0                  | A6/J24_1                  | -       
 *  ADC0_DM0                 | ADC0_DM0/ADC1_DM3/ADC0_SE19                 | A7/J24_3                  | -       
 *  ADC1_DP0                 | ADC1_DP0/ADC0_DP3/ADC1_SE0/ADC0_SE3         | A8/J24_5                  | -       
 *  ADC1_DM0                 | ADC1_DM0/ADC0_DM3/ADC1_SE19                 | A9/J24_7                  | -       
 *  PTC4                     | Disabled                                    | A10/J24_9/SD_SS           | -       
 *  DAC0_OUT                 | DAC0_OUT/CMP1_IN3/ADC0_SE23                 | A11/J24_11                | -       
 *  PTD2                     | GPIOD_2/LLWU_P13                            | D0/J1_2/SD_MOSI/BT_RX     | RF_mosi, Bluetooth_tx       
 *  PTD3                     | GPIOD_3                                     | D1/J1_4/SD_MISO/BT_TX     | RF_miso, Bluetooth_rx       
 *  PTB16                    | GPIOB_16                                    | D2/J1_6/SD_DETECT         | -       
 *  PTA2                     | GPIOA_2                                     | D3/J1_8/LED_GREEN         | Green LED       
 *  PTA4                     | GPIOA_4/LLWU_P3                             | D4/J1_10                  | -       
 *  PTB18                    | GPIOB_18                                    | D5/J1_12                  | -       
 *  PTC3                     | GPIOC_3/LLWU_P7                             | D6/J1_14                  | -       
 *  PTC6                     | GPIOC_6/LLWU_P10                            | D7/J1_16                  | -       
 *  PTB19                    | GPIOB_19                                    | D8/J2_2                   | -       
 *  PTA1                     | GPIOA_1                                     | D9/J2_4/LED_RED           | Red LED       
 *  PTD4                     | GPIOD_4/LLWU_P14                            | D10/J2_6                  | RF_cs*       
 *  PTD6                     | GPIOD_6/LLWU_P15                            | D11/J2_8                  | -       
 *  PTD7                     | GPIOD_7                                     | D12/J2_10                 | -       
 *  PTD5                     | GPIOD_5                                     | D13/J2_12/LED_BLUE        | Blue LED       
 *  PTE0                     | UART1_TX                                    | D14/J2_18/ConTx           | USB Serial Tx       
 *  PTE1                     | UART1_RX                                    | D15/J2_19/ConRx           | USB Serial Rx       
 *  PTA5                     | GPIOA_5                                     | D16/J1_1                  | -       
 *  PTA13                    | GPIOA_13/LLWU_P4                            | D17/J1_3                  | -       
 *  PTA12                    | GPIOA_12                                    | D18/J1_5                  | -       
 *  PTC8                     | GPIOC_8                                     | D19/J1_7                  | -       
 *  PTC9                     | GPIOC_9                                     | D20/J1_9                  | -       
 *  PTC7                     | GPIOC_7                                     | D21/J1_11                 | -       
 *  PTC10                    | GPIOC_10                                    | D22/J1_13                 | -       
 *  PTC5                     | GPIOC_5/LLWU_P9                             | D23/J1_15                 | -       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5/ADC1_SE18        | D24                       | -       
 *  PTA18                    | EXTAL0                                      | EXTAL0                    | Reserved(Crystal)       
 *  EXTAL32                  | EXTAL32                                     | EXTAL32                   | Reserved(Crystal)       
 *  RESET_b                  | RESET_b                                     | RESET_b                   | Reserved(Reset*)       
 *  PTD1                     | ADC0_SE5b                                   | SD_CLK                    | RF_sck       
 *  PTB17                    | GPIOB_17                                    | SW3                       | SW3       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | SWD_CLK                   | Reserved(SWD)       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | SWD_DIO                   | Reserved(SWD)       
 *  USB0_DM                  | USB0_DM                                     | USB0_DM                   | Reserved(USB_DM)       
 *  USB0_DP                  | USB0_DP                                     | USB0_DP                   | Reserved(USB_DP)       
 *  PTC0                     | ADC0_SE14                                   | USB_FLAG                  | -       
 *  VBAT                     | VBAT                                        | VBAT                      | -       
 *  VDD3                     | VDD3                                        | VDD                       | -       
 *  VDD5                     | VDD                                         | VDD5                      | -       
 *  VDDA                     | VDDA                                        | VDDA                      | -       
 *  VOUT33                   | VOUT33                                      | VOUT33                    | -       
 *  VREFH                    | VREFH                                       | VREFH                     | -       
 *  VREFL                    | VREFL                                       | VREFL                     | -       
 *  VREGIN                   | VREGIN                                      | VREGIN                    | -       
 *  VSS3                     | VSS3                                        | VSS                       | -       
 *  VSS5                     | VSS                                         | VSS5                      | -       
 *  VSSA                     | VSSA                                        | VSSA                      | -       
 *  PTA19                    | XTAL0                                       | XTAL0                     | Reserved(Crystal)       
 *  XTAL32                   | XTAL32                                      | XTAL32                    | Reserved(Crystal)       
 *
 *
 * @section PinsByFunction Pins by Function
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  ADC0_DM0                 | ADC0_DM0/ADC1_DM3/ADC0_SE19                 | A7/J24_3                  | -       
 *  ADC0_DP0                 | ADC0_DP0/ADC1_DP3/ADC0_SE0                  | A6/J24_1                  | -       
 *  PTD1                     | ADC0_SE5b                                   | SD_CLK                    | RF_sck       
 *  PTB0                     | ADC0_SE8/ADC1_SE8                           | A0/J24_2                  | -       
 *  PTB1                     | ADC0_SE9/ADC1_SE9                           | A1/J24_4                  | -       
 *  PTB2                     | ADC0_SE12                                   | A5/J24_12/ONBOARD_SCL     | Accelerometer, Magnetometer_scl       
 *  PTB3                     | ADC0_SE13                                   | A4/J24_10/ONBOARD_SDA     | Accelerometer, Magnetometer_sda       
 *  PTC0                     | ADC0_SE14                                   | USB_FLAG                  | -       
 *  PTC1                     | ADC0_SE15                                   | A2/J24_6/SW2              | SW2       
 *  ADC1_DM0                 | ADC1_DM0/ADC0_DM3/ADC1_SE19                 | A9/J24_7                  | -       
 *  ADC1_DP0                 | ADC1_DP0/ADC0_DP3/ADC1_SE0/ADC0_SE3         | A8/J24_5                  | -       
 *  PTC11                    | ADC1_SE7b                                   |                           | RF_ce*       
 *  DAC0_OUT                 | DAC0_OUT/CMP1_IN3/ADC0_SE23                 | A11/J24_11                | -       
 *  PTD0                     | Disabled                                    |                           | Accelerometer, Magnetometer & RF IRQ       
 *  PTA18                    | EXTAL0                                      | EXTAL0                    | Reserved(Crystal)       
 *  EXTAL32                  | EXTAL32                                     | EXTAL32                   | Reserved(Crystal)       
 *  PTC2                     | FTM0_CH1                                    | A3/J24_8                  | -       
 *  PTA1                     | GPIOA_1                                     | D9/J2_4/LED_RED           | Red LED       
 *  PTA2                     | GPIOA_2                                     | D3/J1_8/LED_GREEN         | Green LED       
 *  PTA4                     | GPIOA_4/LLWU_P3                             | D4/J1_10                  | -       
 *  PTA5                     | GPIOA_5                                     | D16/J1_1                  | -       
 *  PTA12                    | GPIOA_12                                    | D18/J1_5                  | -       
 *  PTA13                    | GPIOA_13/LLWU_P4                            | D17/J1_3                  | -       
 *  PTB16                    | GPIOB_16                                    | D2/J1_6/SD_DETECT         | -       
 *  PTB17                    | GPIOB_17                                    | SW3                       | SW3       
 *  PTB18                    | GPIOB_18                                    | D5/J1_12                  | -       
 *  PTB19                    | GPIOB_19                                    | D8/J2_2                   | -       
 *  PTC3                     | GPIOC_3/LLWU_P7                             | D6/J1_14                  | -       
 *  PTC5                     | GPIOC_5/LLWU_P9                             | D23/J1_15                 | -       
 *  PTC6                     | GPIOC_6/LLWU_P10                            | D7/J1_16                  | -       
 *  PTC7                     | GPIOC_7                                     | D21/J1_11                 | -       
 *  PTC8                     | GPIOC_8                                     | D19/J1_7                  | -       
 *  PTC9                     | GPIOC_9                                     | D20/J1_9                  | -       
 *  PTC10                    | GPIOC_10                                    | D22/J1_13                 | -       
 *  PTD2                     | GPIOD_2/LLWU_P13                            | D0/J1_2/SD_MOSI/BT_RX     | RF_mosi, Bluetooth_tx       
 *  PTD3                     | GPIOD_3                                     | D1/J1_4/SD_MISO/BT_TX     | RF_miso, Bluetooth_rx       
 *  PTD4                     | GPIOD_4/LLWU_P14                            | D10/J2_6                  | RF_cs*       
 *  PTD5                     | GPIOD_5                                     | D13/J2_12/LED_BLUE        | Blue LED       
 *  PTD6                     | GPIOD_6/LLWU_P15                            | D11/J2_8                  | -       
 *  PTD7                     | GPIOD_7                                     | D12/J2_10                 | -       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | SWD_CLK                   | Reserved(SWD)       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | SWD_DIO                   | Reserved(SWD)       
 *  RESET_b                  | RESET_b                                     | RESET_b                   | Reserved(Reset*)       
 *  PTE1                     | UART1_RX                                    | D15/J2_19/ConRx           | USB Serial Rx       
 *  PTE0                     | UART1_TX                                    | D14/J2_18/ConTx           | USB Serial Tx       
 *  USB0_DM                  | USB0_DM                                     | USB0_DM                   | Reserved(USB_DM)       
 *  USB0_DP                  | USB0_DP                                     | USB0_DP                   | Reserved(USB_DP)       
 *  VBAT                     | VBAT                                        | VBAT                      | -       
 *  VDD5                     | VDD                                         | VDD5                      | -       
 *  VDD1                     | VDD1                                        | VDD                       | -       
 *  VDD3                     | VDD3                                        | VDD                       | -       
 *  VDDA                     | VDDA                                        | VDDA                      | -       
 *  VOUT33                   | VOUT33                                      | VOUT33                    | -       
 *  VREFH                    | VREFH                                       | VREFH                     | -       
 *  VREFL                    | VREFL                                       | VREFL                     | -       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5/ADC1_SE18        | D24                       | -       
 *  VREGIN                   | VREGIN                                      | VREGIN                    | -       
 *  VSS5                     | VSS                                         | VSS5                      | -       
 *  VSS1                     | VSS1                                        | VSS                       | -       
 *  VSS3                     | VSS3                                        | VSS                       | -       
 *  VSSA                     | VSSA                                        | VSSA                      | -       
 *  PTA19                    | XTAL0                                       | XTAL0                     | Reserved(Crystal)       
 *  XTAL32                   | XTAL32                                      | XTAL32                    | Reserved(Crystal)       
 *
 */

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */

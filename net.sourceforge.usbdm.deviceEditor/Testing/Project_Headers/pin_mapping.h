/**
 * @file      pin_mapping.h (derived from MK20D5.usbdmHardware)
 * @version   1.2.0
 * @brief     Pin declarations for MK20DN32VMP5
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stddef.h>
#include "derivative.h"

#include "pcr.h"

/*
 * Common Mux settings for PCR
 */
#undef FIXED_ADC_FN            
#undef FIXED_GPIO_FN           
#undef FIXED_PORT_CLOCK_REG    
#define FIXED_ADC_FN             0                    // Fixed ADC Multiplexing value
#define FIXED_GPIO_FN            1                    // Fixed GPIO Multiplexing value
#define FIXED_PORT_CLOCK_REG     SCGC5                // Fixed PORT Clock

/*
 * Peripheral clock macros
 */
#define PORT_CLOCK_REG       SCGC5

namespace USBDM {

/** Class to static check signal mapping is valid */
template<class Info, int signalNum> class CheckSignal {
#ifdef DEBUG_BUILD
   static_assert((signalNum<Info::NUM_SIGNALS), "Non-existent signal - Modify Configure.usbdm");
   static_assert((signalNum>=Info::NUM_SIGNALS)||(Info::info[signalNum].gpioBit != UNMAPPED_PCR), "Signal is not mapped to a pin - Modify Configure.usbdm");
   static_assert((signalNum>=Info::NUM_SIGNALS)||(Info::info[signalNum].gpioBit != INVALID_PCR),  "Signal doesn't exist in this device/package");
   static_assert((signalNum>=Info::NUM_SIGNALS)||((Info::info[signalNum].gpioBit == UNMAPPED_PCR)||(Info::info[signalNum].gpioBit == INVALID_PCR)||(Info::info[signalNum].gpioBit >= 0)), "Illegal signal");
#endif
};

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Pins used for Analogue Input
 * @{
 */
#define USBDM_ADC0_IS_DEFINED 
/**
 * Peripheral information for ADC, Analogue Input
 */
class Adc0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = ADC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_ADC0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {ADC0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Indicates interrupt handler has been installed
   static constexpr bool irqHandlerInstalled = false;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t CFG1  = 
       (0<<ADC_CFG1_ADICLK_SHIFT)|
       (2<<ADC_CFG1_MODE_SHIFT)|
       (0<<ADC_CFG1_ADLSMP_SHIFT)|
       (0<<ADC_CFG1_ADIV_SHIFT)|
       (0<<ADC_CFG1_ADLPC_SHIFT);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t CFG2  = 
        ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       (0<<ADC_CFG2_ADLSTS_SHIFT)|
       (0<<ADC_CFG2_ADHSC_SHIFT)|
       (0<<ADC_CFG2_ADACKEN_SHIFT);

   static constexpr uint32_t SC2  =
       (0<<ADC_SC2_REFSEL_SHIFT)|
       (0<<ADC_SC2_DMAEN_SHIFT)|
       (0b000<<ADC_SC2_ACREN_SHIFT)|
       (0<<ADC_SC2_ADTRG_SHIFT);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 24;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: ADC0_SE0             = ADC0_DP0 (G1)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: ADC0_SE3             = ADC0_DP3 (G2)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: ADC0_SE4b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: ADC0_SE5b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: ADC0_SE6b            = PTD5 (C1)                      */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  5,   PORT_PCR_MUX(0)|pcrValue  },
         /*   7: ADC0_SE7b            = PTD6 (B2)                      */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  6,   PORT_PCR_MUX(0)|pcrValue  },
         /*   8: ADC0_SE8             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: ADC0_SE9             = PTB1 (F6)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  1,   PORT_PCR_MUX(0)|pcrValue  },
         /*  10: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  11: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  12: ADC0_SE12            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  13: ADC0_SE13            = PTB3 (E8)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  3,   PORT_PCR_MUX(0)|pcrValue  },
         /*  14: ADC0_SE14            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: ADC0_SE15            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  16: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  17: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  18: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  19: ADC0_SE19            = ADC0_DM0 (F1)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  20: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  21: ADC0_SE21            = ADC0_DM3 (F2)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  22: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  23: ADC0_SE23            = ADC0_SE23 (H2)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Adc0Info,  6>::setPCR(); // ADC0_SE6b       = PTD5 (C1)                     
      PcrTable_T<Adc0Info,  7>::setPCR(); // ADC0_SE7b       = PTD6 (B2)                     
      PcrTable_T<Adc0Info,  9>::setPCR(); // ADC0_SE9        = PTB1 (F6)                     
      PcrTable_T<Adc0Info, 13>::setPCR(); // ADC0_SE13       = PTB3 (E8)                     
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Adc0Info,  6>::setPCR(0); // ADC0_SE6b       = PTD5 (C1)                     
      PcrTable_T<Adc0Info,  7>::setPCR(0); // ADC0_SE7b       = PTD6 (B2)                     
      PcrTable_T<Adc0Info,  9>::setPCR(0); // ADC0_SE9        = PTB1 (F6)                     
      PcrTable_T<Adc0Info, 13>::setPCR(0); // ADC0_SE13       = PTB3 (E8)                     
   }

   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC0_DP0             = ADC0_DP0 (G1)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC0_DP3             = ADC0_DP3 (G2)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC0_DM0             = ADC0_DM0 (F1)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC0_DM3             = ADC0_DM3 (F2)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End ADC_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */
#define USBDM_CMP0_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator
 */
class Cmp0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CMP0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMP_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMP0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP0_IN0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: CMP0_IN1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: CMP0_IN2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: CMP0_IN3             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   5: CMP0_IN5             = VREF_OUT (H1)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP0_OUT             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_CMP1_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator
 */
class Cmp1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CMP1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMP_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMP1_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP1_IN0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: CMP1_IN1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: CMP1_IN3             = ADC0_SE23 (H2)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   5: CMP1_IN5             = VREF_OUT (H1)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP1_OUT             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End CMP_Group
 * @}
 */
/**
 * @addtogroup CMT_Group CMT, Carrier Modulator Transmitter
 * @brief Pins used for Carrier Modulator Transmitter
 * @{
 */
#define USBDM_CMT_IS_DEFINED 
/**
 * Peripheral information for CMT, Carrier Modulator Transmitter
 */
class CmtInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CMT_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMT_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMT_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMT_IRO              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End CMT_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Pins used for Control
 * @{
 */
#define USBDM_CONTROL_IS_DEFINED 
/**
 * Peripheral information for CONTROL, Control
 */
class ControlInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 10;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: RESET_b              = RESET_b (F8)                   */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: JTAG_TCLK            = PTA0 (D3)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  0,   PORT_PCR_MUX(7)|pcrValue  },
         /*   2: SWD_CLK              = PTA0 (D3)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  0,   PORT_PCR_MUX(7)|pcrValue  },
         /*   3: JTAG_TDI             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: JTAG_TDO             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: TRACE_SWO            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: JTAG_TMS             = PTA3 (D5)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  3,   PORT_PCR_MUX(7)|pcrValue  },
         /*   7: SWD_DIO              = PTA3 (D5)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  3,   PORT_PCR_MUX(7)|pcrValue  },
         /*   8: NMI_b                = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: JTAG_TRST_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<ControlInfo,  1>::setPCR(); // JTAG_TCLK       = PTA0 (D3)                     
      PcrTable_T<ControlInfo,  2>::setPCR(); // SWD_CLK         = PTA0 (D3)                     
      PcrTable_T<ControlInfo,  6>::setPCR(); // JTAG_TMS        = PTA3 (D5)                     
      PcrTable_T<ControlInfo,  7>::setPCR(); // SWD_DIO         = PTA3 (D5)                     
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<ControlInfo,  1>::setPCR(0); // JTAG_TCLK       = PTA0 (D3)                     
      PcrTable_T<ControlInfo,  2>::setPCR(0); // SWD_CLK         = PTA0 (D3)                     
      PcrTable_T<ControlInfo,  6>::setPCR(0); // JTAG_TMS        = PTA3 (D5)                     
      PcrTable_T<ControlInfo,  7>::setPCR(0); // SWD_DIO         = PTA3 (D5)                     
   }

};

/** 
 * End Control_Group
 * @}
 */
/**
 * @addtogroup CRC_TODO_Group CRC, (Incomplete)
 * @brief Pins used for (Incomplete)
 * @{
 */
#define USBDM_CRC_IS_DEFINED 
/**
 * Peripheral information for CRC, (Incomplete)
 */
class CrcInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CRC_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_CRC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End CRC_TODO_Group
 * @}
 */
/**
 * @addtogroup DMA_TODO_Group DMA, (Incomplete)
 * @brief Pins used for (Incomplete)
 * @{
 */
#define USBDM_DMA0_IS_DEFINED 
/**
 * Peripheral information for DMA, (Incomplete)
 */
class Dma0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = DMA0_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC7_DMA_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC7);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End DMA_TODO_Group
 * @}
 */
/**
 * @addtogroup DMAMUX_Group DMAMUX, Direct Memory Access (DMA)
 * @brief Pins used for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMAMUX0_IS_DEFINED 
/**
 * Peripheral information for DMAMUX, Direct Memory Access (DMA)
 */
class Dmamux0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = DMAMUX0_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_DMAMUX0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   /* DMA channel numbers */
   enum DmaChannels {
      DMA0_SLOT_Disabled                            = 0,
      DMA0_SLOT_UART0_Receive                       = 2,
      DMA0_SLOT_UART0_Transmit                      = 3,
      DMA0_SLOT_UART1_Receive                       = 4,
      DMA0_SLOT_UART1_Transmit                      = 5,
      DMA0_SLOT_UART2_Receive                       = 6,
      DMA0_SLOT_UART2_Transmit                      = 7,
      DMA0_SLOT_I2S0_Receive                        = 14,
      DMA0_SLOT_I2S0_Transmit                       = 15,
      DMA0_SLOT_SPI0_Receive                        = 16,
      DMA0_SLOT_SPI0_Transmit                       = 17,
      DMA0_SLOT_I2C0                                = 22,
      DMA0_SLOT_FTM0_Ch_0                           = 24,
      DMA0_SLOT_FTM0_Ch_1                           = 25,
      DMA0_SLOT_FTM0_Ch_2                           = 26,
      DMA0_SLOT_FTM0_Ch_3                           = 27,
      DMA0_SLOT_FTM0_Ch_4                           = 28,
      DMA0_SLOT_FTM0_Ch_5                           = 29,
      DMA0_SLOT_FTM0_Ch_6                           = 30,
      DMA0_SLOT_FTM0_Ch_7                           = 31,
      DMA0_SLOT_FTM1_Ch_0                           = 32,
      DMA0_SLOT_FTM1_Ch_1                           = 33,
      DMA0_SLOT_ADC0                                = 40,
      DMA0_SLOT_CMP0                                = 42,
      DMA0_SLOT_CMP1                                = 43,
      DMA0_SLOT_CMT                                 = 47,
      DMA0_SLOT_PDB                                 = 48,
      DMA0_SLOT_PortA                               = 49,
      DMA0_SLOT_PortB                               = 50,
      DMA0_SLOT_PortC                               = 51,
      DMA0_SLOT_PortD                               = 52,
      DMA0_SLOT_PortE                               = 53,
      DMA0_SLOT_AlwaysEnabled0                      = 54,
      DMA0_SLOT_AlwaysEnabled1                      = 55,
      DMA0_SLOT_AlwaysEnabled2                      = 56,
      DMA0_SLOT_AlwaysEnabled3                      = 57,
      DMA0_SLOT_AlwaysEnabled4                      = 48,
      DMA0_SLOT_AlwaysEnabled5                      = 59,
      DMA0_SLOT_AlwaysEnabled6                      = 60,
      DMA0_SLOT_AlwaysEnabled7                      = 61,
      DMA0_SLOT_AlwaysEnabled8                      = 62,
      DMA0_SLOT_AlwaysEnabled9                      = 63,
   };
};

/** 
 * End DMAMUX_Group
 * @}
 */
/**
 * @addtogroup EWM_Group EWM, External Watchdog Monitor
 * @brief Pins used for External Watchdog Monitor
 * @{
 */
#define USBDM_EWM_IS_DEFINED 
/**
 * Peripheral information for EWM, External Watchdog Monitor
 */
class EwmInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = EWM_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_EWM_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: EWM_IN               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: EWM_OUT_b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End EWM_Group
 * @}
 */
/**
 * @addtogroup FTFL_TODO_Group FTFL, (Incomplete)
 * @brief Pins used for (Incomplete)
 * @{
 */
#define USBDM_FTFL_IS_DEFINED 
/**
 * Peripheral information for FTFL, (Incomplete)
 */
class FtflInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = FTFL_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTFL_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End FTFL_TODO_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */
#define USBDM_FTM0_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = FTM0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for SC register
   static constexpr uint32_t SC  = 
       (0<<FTM_SC_CPWMS_SHIFT)|
       ((0|0)<<FTM_SC_TOIE_SHIFT)|
       FTM_SC_CLKS(1)|
       FTM_SC_PS(0);

   //! Default Timer Period
   static constexpr uint32_t PERIOD =  10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM0_CH0             = PTC1 (C6)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  1,   PORT_PCR_MUX(4)|pcrValue  },
         /*   1: FTM0_CH1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: FTM0_CH2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: FTM0_CH3             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: FTM0_CH4             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: FTM0_CH5             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: FTM0_CH6             = PTA1 (D4)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  1,   PORT_PCR_MUX(3)|pcrValue  },
         /*   7: FTM0_CH7             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Ftm0Info,  0>::setPCR(); // FTM0_CH0        = PTC1 (C6)                     
      PcrTable_T<Ftm0Info,  6>::setPCR(); // FTM0_CH6        = PTA1 (D4)                     
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Ftm0Info,  0>::setPCR(0); // FTM0_CH0        = PTC1 (C6)                     
      PcrTable_T<Ftm0Info,  6>::setPCR(0); // FTM0_CH6        = PTA1 (D4)                     
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM0_FLT0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM0_FLT1            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   2: FTM0_FLT2            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   3: FTM0_FLT3            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoCLKIN {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 2;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM0_CLKIN0          = PTA18 (H8)                     */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  18,  PORT_PCR_MUX(4)|pcrValue  },
            /*   1: FTM0_CLKIN1          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
         PcrTable_T<Ftm0Info::InfoCLKIN,  0>::setPCR(); // FTM0_CLKIN0     = PTA18 (H8)                    
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
         PcrTable_T<Ftm0Info::InfoCLKIN,  0>::setPCR(0); // FTM0_CLKIN0     = PTA18 (H8)                    
      }

   }; 

};

#define USBDM_FTM1_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = FTM1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM1_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM1_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for SC register
   static constexpr uint32_t SC  = 
       (0<<FTM_SC_CPWMS_SHIFT)|
       ((0|0)<<FTM_SC_TOIE_SHIFT)|
       FTM_SC_CLKS(1)|
       FTM_SC_PS(0);

   //! Default Timer Period
   static constexpr uint32_t PERIOD =  10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM1_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM1_CH1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 1;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM1_FLT0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 2;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM1_QD_PHA          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM1_QD_PHB          = PTA13 (G6)                     */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  13,  PORT_PCR_MUX(7)|pcrValue  },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
         PcrTable_T<Ftm1Info::InfoQUAD,  1>::setPCR(); // FTM1_QD_PHB     = PTA13 (G6)                    
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
         PcrTable_T<Ftm1Info::InfoQUAD,  1>::setPCR(0); // FTM1_QD_PHB     = PTA13 (G6)                    
      }

   }; 

   class InfoCLKIN {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 2;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM1_CLKIN0          = PTA18 (H8)                     */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  18,  PORT_PCR_MUX(4)|pcrValue  },
            /*   1: FTM1_CLKIN1          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
         PcrTable_T<Ftm1Info::InfoCLKIN,  0>::setPCR(); // FTM1_CLKIN0     = PTA18 (H8)                    
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
         PcrTable_T<Ftm1Info::InfoCLKIN,  0>::setPCR(0); // FTM1_CLKIN0     = PTA18 (H8)                    
      }

   }; 

};

/** 
 * End FTM_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Pins used for Digital Input/Output
 * @{
 */
#define USBDM_GPIOA_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioAInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTA_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOA_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTA_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTA_IRQn};

};

#define USBDM_GPIOB_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioBInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTB_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOB_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTB_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTB_IRQn};

};

#define USBDM_GPIOC_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioCInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTC_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOC_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTC_IRQn};

};

#define USBDM_GPIOD_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioDInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTD_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOD_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTD_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTD_IRQn};

};

#define USBDM_GPIOE_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioEInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTE_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOE_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTE_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTE_IRQn};

};

/** 
 * End GPIO_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Pins used for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2C0_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface
 */
class I2c0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = I2C0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_I2C0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C0_SCL             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2C0_SDA             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End I2C_Group
 * @}
 */
/**
 * @addtogroup I2S_Group I2S, Inter-Integrated-Circuit Interface
 * @brief Pins used for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2S0_IS_DEFINED 
/**
 * Peripheral information for I2S, Inter-Integrated-Circuit Interface
 */
class I2s0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = I2S0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_I2S_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2S0_Tx_IRQn, I2S0_Rx_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2S0_MCLK            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2S0_RX_BCLK         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: I2S0_RX_FS           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: I2S0_TX_BCLK         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: I2S0_TX_FS           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: I2S0_TXD0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: I2S0_RXD0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End I2S_Group
 * @}
 */
/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Pins used for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_LLWU_IS_DEFINED 
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit
 */
class LlwuInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = LLWU_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 16;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: LLWU_P0              = PTE1 (B1)                      */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  1,   PORT_PCR_MUX(1)|pcrValue  },
         /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: LLWU_P3              = PTA4 (G5)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  4,   PORT_PCR_MUX(1)|pcrValue  },
         /*   4: LLWU_P4              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: LLWU_P5              = PTB0 (F7)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  0,   PORT_PCR_MUX(1)|pcrValue  },
         /*   6: LLWU_P6              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: LLWU_P7              = PTC3 (C8)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  3,   PORT_PCR_MUX(1)|pcrValue  },
         /*   8: LLWU_P8              = PTC4 (B8)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  4,   PORT_PCR_MUX(1)|pcrValue  },
         /*   9: LLWU_P9              = PTC5 (A8)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  5,   PORT_PCR_MUX(1)|pcrValue  },
         /*  10: LLWU_P10             = PTC6 (A7)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  6,   PORT_PCR_MUX(1)|pcrValue  },
         /*  11: LLWU_P11             = PTC11 (A5)                     */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  11,  PORT_PCR_MUX(1)|pcrValue  },
         /*  12: LLWU_P12             = PTD0 (C3)                      */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  0,   PORT_PCR_MUX(1)|pcrValue  },
         /*  13: LLWU_P13             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  14: LLWU_P14             = PTD4 (A3)                      */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  4,   PORT_PCR_MUX(1)|pcrValue  },
         /*  15: LLWU_P15             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<LlwuInfo,  0>::setPCR(); // LLWU_P0         = PTE1 (B1)                     
      PcrTable_T<LlwuInfo,  3>::setPCR(); // LLWU_P3         = PTA4 (G5)                     
      PcrTable_T<LlwuInfo,  5>::setPCR(); // LLWU_P5         = PTB0 (F7)                     
      PcrTable_T<LlwuInfo,  7>::setPCR(); // LLWU_P7         = PTC3 (C8)                     
      PcrTable_T<LlwuInfo,  8>::setPCR(); // LLWU_P8         = PTC4 (B8)                     
      PcrTable_T<LlwuInfo,  9>::setPCR(); // LLWU_P9         = PTC5 (A8)                     
      PcrTable_T<LlwuInfo, 10>::setPCR(); // LLWU_P10        = PTC6 (A7)                     
      PcrTable_T<LlwuInfo, 11>::setPCR(); // LLWU_P11        = PTC11 (A5)                    
      PcrTable_T<LlwuInfo, 12>::setPCR(); // LLWU_P12        = PTD0 (C3)                     
      PcrTable_T<LlwuInfo, 14>::setPCR(); // LLWU_P14        = PTD4 (A3)                     
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<LlwuInfo,  0>::setPCR(0); // LLWU_P0         = PTE1 (B1)                     
      PcrTable_T<LlwuInfo,  3>::setPCR(0); // LLWU_P3         = PTA4 (G5)                     
      PcrTable_T<LlwuInfo,  5>::setPCR(0); // LLWU_P5         = PTB0 (F7)                     
      PcrTable_T<LlwuInfo,  7>::setPCR(0); // LLWU_P7         = PTC3 (C8)                     
      PcrTable_T<LlwuInfo,  8>::setPCR(0); // LLWU_P8         = PTC4 (B8)                     
      PcrTable_T<LlwuInfo,  9>::setPCR(0); // LLWU_P9         = PTC5 (A8)                     
      PcrTable_T<LlwuInfo, 10>::setPCR(0); // LLWU_P10        = PTC6 (A7)                     
      PcrTable_T<LlwuInfo, 11>::setPCR(0); // LLWU_P11        = PTC11 (A5)                    
      PcrTable_T<LlwuInfo, 12>::setPCR(0); // LLWU_P12        = PTD0 (C3)                     
      PcrTable_T<LlwuInfo, 14>::setPCR(0); // LLWU_P14        = PTD4 (A3)                     
   }

};

/** 
 * End LLWU_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Pins used for Low Power Timer
 * @{
 */
#define USBDM_LPTMR0_IS_DEFINED 
/**
 * Peripheral information for LPTMR, Low Power Timer
 */
class Lptmr0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = LPTMR0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_LPTMR_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LPTMR0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default PSR value
   static constexpr uint32_t PSR = 
      LPTMR_PSR_PRESCALE(0)|
      LPTMR_PSR_PCS(0)|
      (0<<LPTMR_PSR_PBYP_SHIFT)|
      (0<<LPTMR_PSR_PCS_SHIFT);

   //! Default CSR value
   static constexpr uint32_t CSR = 
      (0<<LPTMR_CSR_TIE_SHIFT)|
      (0<<LPTMR_CSR_TMS_SHIFT)|
      (0<<LPTMR_CSR_TFC_SHIFT)|
      (0<<LPTMR_CSR_TPP_SHIFT)|
      LPTMR_CSR_TPS(0);

   //! Default Timer period
   static constexpr uint32_t PERIOD = 10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 3;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: LPTMR0_ALT1          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: LPTMR0_ALT2          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End LPTMR_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Pins used for Multipurpose Clock Generator
 * @{
 */
#define USBDM_MCG_IS_DEFINED 
/**
 * Peripheral information for MCG, Multipurpose Clock Generator
 */
class McgInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = MCG_BasePtr;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   enum ClockMode {
      ClockMode_None = -1,
      ClockMode_FEI  = 0,
      ClockMode_FEE,
      ClockMode_FBI,
      ClockMode_BLPI,
      ClockMode_FBE,
      ClockMode_BLPE,
      ClockMode_PBE,
      ClockMode_PEE,
   };

   //! Clock Mode
   static constexpr ClockMode clockMode = ClockMode_PEE;

   //! Control Register 1
   static constexpr uint32_t MCG_C1 =
      MCG_C1_FRDIV(0)   | // FRDIV    FLL External Reference Divider
      MCG_C1_IRCLKEN(0) | // IRCLEN   Internal Reference Clock Enable
      MCG_C1_IREFSTEN(0); // IREFSTEN Internal Reference Stop Enable

   //! Control Register 2
   static constexpr uint32_t MCG_C2 =
      MCG_C2_LOCRE0(0) | // LOLRE0  Loss of Clock Reset Enable
      MCG_C2_RANGE0(0) | // RANGE   Frequency Range Select
      MCG_C2_HGO0(1)   | // HGO     High Gain Oscillator Select
      MCG_C2_EREFS0(0) | // EREFS   External Reference Select
      MCG_C2_IRCS(0);    // IRCS    Internal Reference Clock Select

   //! Control Register 4
   static constexpr uint32_t MCG_C4 =
      MCG_C4_DMX32(0)     | // DMX32    DCO lock range
      MCG_C4_DRST_DRS(0);   // DRST_DRS DCO Range Select

   //! Control Register 5
   static constexpr uint32_t MCG_C5 =
      MCG_C5_PLLCLKEN0(0)  | // PLLCLKEN0 PLL Clock Enable
      MCG_C5_PLLSTEN0(0)   | // PLLSTEN0  PLL Stop Enable
      MCG_C5_PRDIV0(11);     // PRDIV0    PLL External Reference Divider

   //! Control Register 6
   static constexpr uint32_t MCG_C6 =
      MCG_C6_LOLIE0(0) | // LOLIE0 Loss of Lock interrupt Enable
      MCG_C6_CME0(1)   | // CME0   Clock Monitor Enable
      MCG_C6_VDIV0(1);   // VDIV0  PLL VCO Divider

   //! Status and Control Register
   static constexpr uint32_t MCG_SC =
      MCG_SC_FCRDIV(4); // FCRDIV Internal Clock Reference Divider

   //! Control Register 7
   static constexpr uint32_t MCG_C7 =
      MCG_C7_OSCSEL(1); // OSCSEL MCG OSC Clock Select

   //! Control Register 8
   static constexpr uint32_t MCG_C8 =
      MCG_C8_LOCRE1(0) | // LOCRE1 RTC Loss of Clock Reset Enable
      MCG_C8_LOLRE(0)  | // LOLRE  PLL Loss of Lock Reset Enable
      MCG_C8_CME1(0);    // CME1   Clock Monitor Enable 1

   #ifdef MCG_C9_PLL_CME
   //! Control Register 9
   static constexpr uint32_t MCG_C9 =
      MCG_C9_PLL_CME(0)   | // PLL_CME MCG External PLL Clock Monitor Enable
      MCG_C9_PLL_LOCRE(0);  // PLL_LOCRE   MCG External PLL Loss of Clock Reset Enable
   #endif

   #ifdef MCG_C11_PLLCS
   //! Control Register 11
   static constexpr uint32_t MCG_C11 =
      MCG_C11_PLLCS(0); // PLLCS PLL Clock Select
   #endif

   //! Clock divider
   static constexpr uint32_t SIM_CLKDIV1 = 
      SIM_CLKDIV1_OUTDIV4(9) | // SIM_CLKDIV1_OUTDIV4
   #ifdef SIM_CLKDIV1_OUTDIV3
      SIM_CLKDIV1_OUTDIV3(1) | // SIM_CLKDIV1_OUTDIV3
   #endif
      SIM_CLKDIV1_OUTDIV2(1) | // SIM_CLKDIV1_OUTDIV2
      SIM_CLKDIV1_OUTDIV1(0);  // SIM_CLKDIV1_OUTDIV1
};

/** 
 * End MCG_Group
 * @}
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Pins used for Crystal Oscillator
 * @{
 */
#define USBDM_OSC0_IS_DEFINED 
/**
 * Peripheral information for OSC, Crystal Oscillator
 */
class Osc0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = OSC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Oscillator control register
   static constexpr uint32_t OSC_CR =
      (0<<OSC_CR_ERCLKEN_SHIFT)|
      (0<<OSC_CR_EREFSTEN_SHIFT)|
      (2<<OSC_CR_SC16P_SHIFT);

#ifdef OSC_DIV_ERPS_MASK
   //! OSC Clock divider register
   static constexpr uint32_t OSC_DIV =
      (0<<OSC_DIV_ERPS_SHIFT);   
#endif

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: XTAL0                = PTA19 (G8)                     */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  19,  PORT_PCR_MUX(0)|pcrValue  },
         /*   1: EXTAL0               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Osc0Info,  0>::setPCR(); // XTAL0           = PTA19 (G8)                    
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Osc0Info,  0>::setPCR(0); // XTAL0           = PTA19 (G8)                    
   }

};

/** 
 * End OSC_Group
 * @}
 */
/**
 * @addtogroup PDB_Group PDB, Programmable Dely Block
 * @brief Pins used for Programmable Dely Block
 * @{
 */
#define USBDM_PDB0_IS_DEFINED 
/**
 * Peripheral information for PDB, Programmable Dely Block
 */
class Pdb0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = PDB0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_PDB_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PDB0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: PDB0_EXTRG           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End PDB_Group
 * @}
 */
/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Pins used for Programmable Interrupt Timer
 * @{
 */
#define USBDM_PIT_IS_DEFINED 
/**
 * Peripheral information for PIT, Programmable Interrupt Timer
 */
class PitInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = PIT_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_PIT_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 4;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PIT0_IRQn, PIT1_IRQn, PIT2_IRQn, PIT3_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for PIT->SC register
   static constexpr uint32_t loadValue  = 10000;

   //! PIT operation in debug mode
   static constexpr uint32_t mcrValue = (0<<PIT_MCR_FRZ_SHIFT);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

};

/** 
 * End PIT_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Pins used for Power
 * @{
 */
#define USBDM_POWER_IS_DEFINED 
/**
 * Peripheral information for POWER, Power
 */
class PowerInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 13;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VBAT                 = VBAT (H5)                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: VDD1                 = VDD1 (C5)                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: VDD2                 = VDD2 (G7)                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   3: VDD3                 = VDD3 (E4)                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: VDDA                 = VDDA (F4)                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   5: VOUT33               = VOUT33 (E2)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: VREFH                = VREFH (G4)                     */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   7: VREFL                = VREFL (G3)                     */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   8: VREGIN               = VREGIN (D2)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   9: VSS1                 = VSS1 (C4)                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  10: VSS2                 = VSS2 (H7)                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  11: VSS3                 = VSS3 (E3)                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  12: VSSA                 = VSSA (F3)                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End Power_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Pins used for Real Time Clock
 * @{
 */
#define USBDM_RTC_IS_DEFINED 
/**
 * Peripheral information for RTC, Real Time Clock
 */
class RtcInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = RTC_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_RTC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {RTC_Alarm_IRQn, RTC_Seconds_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Indicates interrupt handler has been installed
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Oscillator control register
   static constexpr uint32_t RTC_CR =
      (0<<RTC_CR_OSCE_SHIFT)|
      (0<<RTC_CR_CLKO_SHIFT)|
      (0<<RTC_CR_UM_SHIFT)|
      (0<<RTC_CR_SUP_SHIFT)|
      (0<<RTC_CR_WPE_SHIFT)|
      (2<<RTC_CR_SC16P_SHIFT);

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 3;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: XTAL32               = XTAL32 (H3)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: EXTAL32              = EXTAL32 (H4)                   */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: RTC_CLKOUT           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End RTC_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Pins used for Serial Peripheral Interface
 * @{
 */
#define USBDM_SPI0_IS_DEFINED 
/**
 * Peripheral information for SPI, Serial Peripheral Interface
 */
class Spi0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = SPI0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_SPI0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {SPI0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

#ifdef SPI_CTAR_LSBFE_SHIFT
   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint32_t modeValue = (0<<SPI_CTAR_LSBFE_SHIFT)|(0<<SPI_CTAR_CPHA_SHIFT);

#endif
   //! Default speed (Hz)
   static constexpr uint32_t speed = 100000;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SPI0_SCK             = PTD1 (A4)                      */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  1,   PORT_PCR_MUX(2)|pcrValue  },
         /*   1: SPI0_SIN             = PTD3 (B3)                      */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  3,   PORT_PCR_MUX(2)|pcrValue  },
         /*   2: SPI0_SOUT            = PTD2 (C2)                      */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  2,   PORT_PCR_MUX(2)|pcrValue  },
         /*   3: SPI0_PCS0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: SPI0_PCS1            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: SPI0_PCS2            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: SPI0_PCS3            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: SPI0_PCS4            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Spi0Info,  0>::setPCR(); // SPI0_SCK        = PTD1 (A4)                     
      PcrTable_T<Spi0Info,  1>::setPCR(); // SPI0_SIN        = PTD3 (B3)                     
      PcrTable_T<Spi0Info,  2>::setPCR(); // SPI0_SOUT       = PTD2 (C2)                     
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Spi0Info,  0>::setPCR(0); // SPI0_SCK        = PTD1 (A4)                     
      PcrTable_T<Spi0Info,  1>::setPCR(0); // SPI0_SIN        = PTD3 (B3)                     
      PcrTable_T<Spi0Info,  2>::setPCR(0); // SPI0_SOUT       = PTD2 (C2)                     
   }

};

/** 
 * End SPI_Group
 * @}
 */
/**
 * @addtogroup TSI_Group TSI, Low-leakage Wake-up Unit
 * @brief Pins used for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_TSI0_IS_DEFINED 
/**
 * Peripheral information for TSI, Low-leakage Wake-up Unit
 */
class Tsi0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = TSI0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_TSI0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {TSI0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 16;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: TSI0_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: TSI0_CH1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: TSI0_CH2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: TSI0_CH3             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: TSI0_CH4             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: TSI0_CH5             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: TSI0_CH6             = PTB1 (F6)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  1,   PORT_PCR_MUX(0)|pcrValue  },
         /*   7: TSI0_CH7             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: TSI0_CH8             = PTB3 (E8)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  3,   PORT_PCR_MUX(0)|pcrValue  },
         /*   9: TSI0_CH9             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: TSI0_CH10            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  11: TSI0_CH11            = PTB18 (D6)                     */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  18,  PORT_PCR_MUX(0)|pcrValue  },
         /*  12: TSI0_CH12            = PTB19 (C7)                     */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  19,  PORT_PCR_MUX(0)|pcrValue  },
         /*  13: TSI0_CH13            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  14: TSI0_CH14            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: TSI0_CH15            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Tsi0Info,  6>::setPCR(); // TSI0_CH6        = PTB1 (F6)                     
      PcrTable_T<Tsi0Info,  8>::setPCR(); // TSI0_CH8        = PTB3 (E8)                     
      PcrTable_T<Tsi0Info, 11>::setPCR(); // TSI0_CH11       = PTB18 (D6)                    
      PcrTable_T<Tsi0Info, 12>::setPCR(); // TSI0_CH12       = PTB19 (C7)                    
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Tsi0Info,  6>::setPCR(0); // TSI0_CH6        = PTB1 (F6)                     
      PcrTable_T<Tsi0Info,  8>::setPCR(0); // TSI0_CH8        = PTB3 (E8)                     
      PcrTable_T<Tsi0Info, 11>::setPCR(0); // TSI0_CH11       = PTB18 (D6)                    
      PcrTable_T<Tsi0Info, 12>::setPCR(0); // TSI0_CH12       = PTB19 (C7)                    
   }

};

/** 
 * End TSI_Group
 * @}
 */
/**
 * @addtogroup UART_Group UART, Universal Asynchronous Receiver/Transmitter
 * @brief Pins used for Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_UART0_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = UART0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART0_RX_TX_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 5;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART0_TX             = PTB17 (D7)                     */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  17,  PORT_PCR_MUX(3)|pcrValue  },
         /*   1: UART0_RX             = PTB16 (E6)                     */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  16,  PORT_PCR_MUX(3)|pcrValue  },
         /*   2: UART0_RTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART0_CTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: UART0_COL_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Uart0Info,  0>::setPCR(); // UART0_TX        = PTB17 (D7)                    
      PcrTable_T<Uart0Info,  1>::setPCR(); // UART0_RX        = PTB16 (E6)                    
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Uart0Info,  0>::setPCR(0); // UART0_TX        = PTB17 (D7)                    
      PcrTable_T<Uart0Info,  1>::setPCR(0); // UART0_RX        = PTB16 (E6)                    
   }

};

#define USBDM_UART1_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = UART1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART1_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART1_RX_TX_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART1_TX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART1_RX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: UART1_RTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART1_CTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_UART2_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart2Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = UART2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART2_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART2_RX_TX_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemBusClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART2_TX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART2_RX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: UART2_RTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART2_CTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End UART_Group
 * @}
 */
/**
 * @addtogroup USB_Group USB, USB OTG Controller
 * @brief Pins used for USB OTG Controller
 * @{
 */
#define USBDM_USB0_IS_DEFINED 
/**
 * Peripheral information for USB, USB OTG Controller
 */
class Usb0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = USB0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_USBOTG_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {USB0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: USB0_DM              = USB0_DM (D1)                   */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: USB0_DP              = USB0_DP (E1)                   */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: USB_CLKIN            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: USB_SOF_OUT          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End USB_Group
 * @}
 */
/**
 * @addtogroup USBDCD_Group USBDCD, USB Device Charger Detection
 * @brief Pins used for USB Device Charger Detection
 * @{
 */
#define USBDM_USBDCD_IS_DEFINED 
/**
 * Peripheral information for USBDCD, USB Device Charger Detection
 */
class UsbdcdInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = USBDCD_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_USBDCD_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End USBDCD_Group
 * @}
 */
/**
 * @addtogroup VREF_Group VREF, Voltage Reference
 * @brief Pins used for Voltage Reference
 * @{
 */
#define USBDM_VREF_IS_DEFINED 
/**
 * Peripheral information for VREF, Voltage Reference
 */
class VrefInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = VREF_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_VREF_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VREF_OUT             = VREF_OUT (H1)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End VREF_Group
 * @}
 */

} // End namespace USBDM

#include "adc.h"
#include "ftm.h"
#include "gpio.h"

namespace USBDM {

/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Pins used for Analogue Input
 * @{
 */
using adc_F1               = const USBDM::Adc0Channel<0>;
//using adc_F1               = const USBDM::Adc0Channel<19>;
using adc_F2               = const USBDM::Adc0Channel<3>;
//using adc_F2               = const USBDM::Adc0Channel<21>;
using adc_G1               = const USBDM::Adc0Channel<0>;
//using adc_G1               = const USBDM::Adc0Channel<0>;
using adc_G2               = const USBDM::Adc0Channel<3>;
//using adc_G2               = const USBDM::Adc0Channel<3>;
using adc_H2               = const USBDM::Adc0Channel<23>;
using adc_F6               = const USBDM::Adc0Channel<9>;
using adc_E8               = const USBDM::Adc0Channel<13>;
using adc_C1               = const USBDM::Adc0Channel<6>;
using adc_B2               = const USBDM::Adc0Channel<7>;
/** 
 * End ADC_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */
using ftm_D4               = const USBDM::Ftm0Channel<6>;
using ftm_C6               = const USBDM::Ftm0Channel<0>;
/** 
 * End FTM_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Pins used for Digital Input/Output
 * @{
 */
using gpio_E5              = const USBDM::GpioA<2>;
using gpio_G5              = const USBDM::GpioA<4>;
using gpio_F5              = const USBDM::GpioA<5>;
using gpio_H6              = const USBDM::GpioA<12>;
using gpio_F7              = const USBDM::GpioB<0>;
using gpio_E7              = const USBDM::GpioB<2>;
using gpio_D8              = const USBDM::GpioC<0>;
using gpio_B7              = const USBDM::GpioC<2>;
using gpio_C8              = const USBDM::GpioC<3>;
using gpio_B8              = const USBDM::GpioC<4>;
using gpio_A8              = const USBDM::GpioC<5>;
using gpio_A7              = const USBDM::GpioC<6>;
using gpio_B6              = const USBDM::GpioC<7>;
using gpio_A6              = const USBDM::GpioC<8>;
using gpio_B5              = const USBDM::GpioC<9>;
using gpio_B4              = const USBDM::GpioC<10>;
using gpio_A5              = const USBDM::GpioC<11>;
using gpio_C3              = const USBDM::GpioD<0>;
using gpio_A3              = const USBDM::GpioD<4>;
using gpio_A2              = const USBDM::GpioD<7>;
using gpio_A1              = const USBDM::GpioE<0>;
using gpio_B1              = const USBDM::GpioE<1>;
/** 
 * End GPIO_Group
 * @}
 */
/**
 * Used to configure pin-mapping before 1st use of peripherals
 */
extern void mapAllPins();

} // End namespace USBDM
/**
 *
 * @mainpage Summary
 *
 * @section PinsByPinName Pins by Pin Name
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  ADC0_DM0                 | ADC0_DM0/ADC0_SE19                          | F1                        | Photo-transistor       
 *  ADC0_DM3                 | ADC0_DM3/ADC0_SE21                          | F2                        | Temperature sensor       
 *  ADC0_DP0                 | ADC0_DP0/ADC0_SE0                           | G1                        | -       
 *  ADC0_DP3                 | ADC0_DP3/ADC0_SE3                           | G2                        | -       
 *  ADC0_SE23                | ADC0_SE23/CMP1_IN3                          | H2                        | -       
 *  EXTAL32                  | EXTAL32                                     | H4                        | Reserved(EXTAL32)       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | D3                        | Reserved(SWD)       
 *  PTA1                     | FTM0_CH6                                    | D4                        | -       
 *  PTA2                     | GPIOA_2                                     | E5                        | Blue LED, LCD_cs*       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | D5                        | Reserved(SWD)       
 *  PTA4                     | GPIOA_4/LLWU_P3                             | G5                        | -       
 *  PTA5                     | GPIOA_5                                     | F5                        | -       
 *  PTA12                    | GPIOA_12                                    | H6                        | LCD_Reset*       
 *  PTA13                    | FTM1_QD_PHB                                 | G6                        | -       
 *  PTA18                    | FTM0_CLKIN0/FTM1_CLKIN0                     | H8                        | Reserved       
 *  PTA19                    | XTAL0                                       | G8                        | Reserved       
 *  PTB0                     | GPIOB_0/LLWU_P5                             | F7                        | Accelerometer       
 *  PTB1                     | ADC0_SE9/TSI0_CH6                           | F6                        | Accelerometer       
 *  PTB2                     | GPIOB_2                                     | E7                        | -       
 *  PTB3                     | ADC0_SE13/TSI0_CH8                          | E8                        | -       
 *  PTB16                    | UART0_RX                                    | E6                        | USB_serial       
 *  PTB17                    | UART0_TX                                    | D7                        | USB_serial       
 *  PTB18                    | TSI0_CH11                                   | D6                        | Touch 1       
 *  PTB19                    | TSI0_CH12                                   | C7                        | Touch 2       
 *  PTC0                     | GPIOC_0                                     | D8                        | -       
 *  PTC1                     | FTM0_CH0                                    | C6                        | -       
 *  PTC2                     | GPIOC_2                                     | B7                        | LCD_backlight       
 *  PTC3                     | GPIOC_3/LLWU_P7                             | C8                        | Red LED       
 *  PTC4                     | GPIOC_4/LLWU_P8                             | B8                        | -       
 *  PTC5                     | GPIOC_5/LLWU_P9                             | A8                        | -       
 *  PTC6                     | GPIOC_6/LLWU_P10                            | A7                        | -       
 *  PTC7                     | GPIOC_7                                     | B6                        | -       
 *  PTC8                     | GPIOC_8                                     | A6                        | -       
 *  PTC9                     | GPIOC_9                                     | B5                        | -       
 *  PTC10                    | GPIOC_10                                    | B4                        | -       
 *  PTC11                    | GPIOC_11/LLWU_P11                           | A5                        | -       
 *  PTD0                     | GPIOD_0/LLWU_P12                            | C3                        | -       
 *  PTD1                     | SPI0_SCK                                    | A4                        | LCD_sck       
 *  PTD2                     | SPI0_SOUT                                   | C2                        | LCD_sin       
 *  PTD3                     | SPI0_SIN                                    | B3                        | -       
 *  PTD4                     | GPIOD_4/LLWU_P14                            | A3                        | Green LED       
 *  PTD5                     | ADC0_SE6b                                   | C1                        | -       
 *  PTD6                     | ADC0_SE7b                                   | B2                        | -       
 *  PTD7                     | GPIOD_7                                     | A2                        | -       
 *  PTE0                     | GPIOE_0                                     | A1                        | -       
 *  PTE1                     | GPIOE_1/LLWU_P0                             | B1                        | -       
 *  RESET_b                  | RESET_b                                     | F8                        | Reserved(Reset*)       
 *  USB0_DM                  | USB0_DM                                     | D1                        | Reserved(USB_DM)       
 *  USB0_DP                  | USB0_DP                                     | E1                        | Reserved(USB_DP)       
 *  VBAT                     | VBAT                                        | H5                        | -       
 *  VDD1                     | VDD1                                        | C5                        | -       
 *  VDD2                     | VDD2                                        | G7                        | -       
 *  VDD3                     | VDD3                                        | E4                        | -       
 *  VDDA                     | VDDA                                        | F4                        | -       
 *  VOUT33                   | VOUT33                                      | E2                        | -       
 *  VREFH                    | VREFH                                       | G4                        | -       
 *  VREFL                    | VREFL                                       | G3                        | -       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5                  | H1                        | -       
 *  VREGIN                   | VREGIN                                      | D2                        | -       
 *  VSS1                     | VSS1                                        | C4                        | -       
 *  VSS2                     | VSS2                                        | H7                        | -       
 *  VSS3                     | VSS3                                        | E3                        | -       
 *  VSSA                     | VSSA                                        | F3                        | -       
 *  XTAL32                   | XTAL32                                      | H3                        | Reserved(XTAL32)       
 *
 *
 * @section PinsByLocation Pins by Location
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTE0                     | GPIOE_0                                     | A1                        | -       
 *  PTD7                     | GPIOD_7                                     | A2                        | -       
 *  PTD4                     | GPIOD_4/LLWU_P14                            | A3                        | Green LED       
 *  PTD1                     | SPI0_SCK                                    | A4                        | LCD_sck       
 *  PTC11                    | GPIOC_11/LLWU_P11                           | A5                        | -       
 *  PTC8                     | GPIOC_8                                     | A6                        | -       
 *  PTC6                     | GPIOC_6/LLWU_P10                            | A7                        | -       
 *  PTC5                     | GPIOC_5/LLWU_P9                             | A8                        | -       
 *  PTE1                     | GPIOE_1/LLWU_P0                             | B1                        | -       
 *  PTD6                     | ADC0_SE7b                                   | B2                        | -       
 *  PTD3                     | SPI0_SIN                                    | B3                        | -       
 *  PTC10                    | GPIOC_10                                    | B4                        | -       
 *  PTC9                     | GPIOC_9                                     | B5                        | -       
 *  PTC7                     | GPIOC_7                                     | B6                        | -       
 *  PTC2                     | GPIOC_2                                     | B7                        | LCD_backlight       
 *  PTC4                     | GPIOC_4/LLWU_P8                             | B8                        | -       
 *  PTD5                     | ADC0_SE6b                                   | C1                        | -       
 *  PTD2                     | SPI0_SOUT                                   | C2                        | LCD_sin       
 *  PTD0                     | GPIOD_0/LLWU_P12                            | C3                        | -       
 *  VSS1                     | VSS1                                        | C4                        | -       
 *  VDD1                     | VDD1                                        | C5                        | -       
 *  PTC1                     | FTM0_CH0                                    | C6                        | -       
 *  PTB19                    | TSI0_CH12                                   | C7                        | Touch 2       
 *  PTC3                     | GPIOC_3/LLWU_P7                             | C8                        | Red LED       
 *  USB0_DM                  | USB0_DM                                     | D1                        | Reserved(USB_DM)       
 *  VREGIN                   | VREGIN                                      | D2                        | -       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | D3                        | Reserved(SWD)       
 *  PTA1                     | FTM0_CH6                                    | D4                        | -       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | D5                        | Reserved(SWD)       
 *  PTB18                    | TSI0_CH11                                   | D6                        | Touch 1       
 *  PTB17                    | UART0_TX                                    | D7                        | USB_serial       
 *  PTC0                     | GPIOC_0                                     | D8                        | -       
 *  USB0_DP                  | USB0_DP                                     | E1                        | Reserved(USB_DP)       
 *  VOUT33                   | VOUT33                                      | E2                        | -       
 *  VSS3                     | VSS3                                        | E3                        | -       
 *  VDD3                     | VDD3                                        | E4                        | -       
 *  PTA2                     | GPIOA_2                                     | E5                        | Blue LED, LCD_cs*       
 *  PTB16                    | UART0_RX                                    | E6                        | USB_serial       
 *  PTB2                     | GPIOB_2                                     | E7                        | -       
 *  PTB3                     | ADC0_SE13/TSI0_CH8                          | E8                        | -       
 *  ADC0_DM0                 | ADC0_DM0/ADC0_SE19                          | F1                        | Photo-transistor       
 *  ADC0_DM3                 | ADC0_DM3/ADC0_SE21                          | F2                        | Temperature sensor       
 *  VSSA                     | VSSA                                        | F3                        | -       
 *  VDDA                     | VDDA                                        | F4                        | -       
 *  PTA5                     | GPIOA_5                                     | F5                        | -       
 *  PTB1                     | ADC0_SE9/TSI0_CH6                           | F6                        | Accelerometer       
 *  PTB0                     | GPIOB_0/LLWU_P5                             | F7                        | Accelerometer       
 *  RESET_b                  | RESET_b                                     | F8                        | Reserved(Reset*)       
 *  ADC0_DP0                 | ADC0_DP0/ADC0_SE0                           | G1                        | -       
 *  ADC0_DP3                 | ADC0_DP3/ADC0_SE3                           | G2                        | -       
 *  VREFL                    | VREFL                                       | G3                        | -       
 *  VREFH                    | VREFH                                       | G4                        | -       
 *  PTA4                     | GPIOA_4/LLWU_P3                             | G5                        | -       
 *  PTA13                    | FTM1_QD_PHB                                 | G6                        | -       
 *  VDD2                     | VDD2                                        | G7                        | -       
 *  PTA19                    | XTAL0                                       | G8                        | Reserved       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5                  | H1                        | -       
 *  ADC0_SE23                | ADC0_SE23/CMP1_IN3                          | H2                        | -       
 *  XTAL32                   | XTAL32                                      | H3                        | Reserved(XTAL32)       
 *  EXTAL32                  | EXTAL32                                     | H4                        | Reserved(EXTAL32)       
 *  VBAT                     | VBAT                                        | H5                        | -       
 *  PTA12                    | GPIOA_12                                    | H6                        | LCD_Reset*       
 *  VSS2                     | VSS2                                        | H7                        | -       
 *  PTA18                    | FTM0_CLKIN0/FTM1_CLKIN0                     | H8                        | Reserved       
 *
 *
 * @section PinsByFunction Pins by Function
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  ADC0_DM0                 | ADC0_DM0/ADC0_SE19                          | F1                        | Photo-transistor       
 *  ADC0_DM3                 | ADC0_DM3/ADC0_SE21                          | F2                        | Temperature sensor       
 *  ADC0_DP0                 | ADC0_DP0/ADC0_SE0                           | G1                        | -       
 *  ADC0_DP3                 | ADC0_DP3/ADC0_SE3                           | G2                        | -       
 *  PTD5                     | ADC0_SE6b                                   | C1                        | -       
 *  PTD6                     | ADC0_SE7b                                   | B2                        | -       
 *  PTB1                     | ADC0_SE9/TSI0_CH6                           | F6                        | Accelerometer       
 *  PTB3                     | ADC0_SE13/TSI0_CH8                          | E8                        | -       
 *  ADC0_SE23                | ADC0_SE23/CMP1_IN3                          | H2                        | -       
 *  EXTAL32                  | EXTAL32                                     | H4                        | Reserved(EXTAL32)       
 *  PTC1                     | FTM0_CH0                                    | C6                        | -       
 *  PTA1                     | FTM0_CH6                                    | D4                        | -       
 *  PTA18                    | FTM0_CLKIN0/FTM1_CLKIN0                     | H8                        | Reserved       
 *  PTA13                    | FTM1_QD_PHB                                 | G6                        | -       
 *  PTA2                     | GPIOA_2                                     | E5                        | Blue LED, LCD_cs*       
 *  PTA4                     | GPIOA_4/LLWU_P3                             | G5                        | -       
 *  PTA5                     | GPIOA_5                                     | F5                        | -       
 *  PTA12                    | GPIOA_12                                    | H6                        | LCD_Reset*       
 *  PTB0                     | GPIOB_0/LLWU_P5                             | F7                        | Accelerometer       
 *  PTB2                     | GPIOB_2                                     | E7                        | -       
 *  PTC0                     | GPIOC_0                                     | D8                        | -       
 *  PTC2                     | GPIOC_2                                     | B7                        | LCD_backlight       
 *  PTC3                     | GPIOC_3/LLWU_P7                             | C8                        | Red LED       
 *  PTC4                     | GPIOC_4/LLWU_P8                             | B8                        | -       
 *  PTC5                     | GPIOC_5/LLWU_P9                             | A8                        | -       
 *  PTC6                     | GPIOC_6/LLWU_P10                            | A7                        | -       
 *  PTC7                     | GPIOC_7                                     | B6                        | -       
 *  PTC8                     | GPIOC_8                                     | A6                        | -       
 *  PTC9                     | GPIOC_9                                     | B5                        | -       
 *  PTC10                    | GPIOC_10                                    | B4                        | -       
 *  PTC11                    | GPIOC_11/LLWU_P11                           | A5                        | -       
 *  PTD0                     | GPIOD_0/LLWU_P12                            | C3                        | -       
 *  PTD4                     | GPIOD_4/LLWU_P14                            | A3                        | Green LED       
 *  PTD7                     | GPIOD_7                                     | A2                        | -       
 *  PTE0                     | GPIOE_0                                     | A1                        | -       
 *  PTE1                     | GPIOE_1/LLWU_P0                             | B1                        | -       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | D3                        | Reserved(SWD)       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | D5                        | Reserved(SWD)       
 *  RESET_b                  | RESET_b                                     | F8                        | Reserved(Reset*)       
 *  PTD1                     | SPI0_SCK                                    | A4                        | LCD_sck       
 *  PTD3                     | SPI0_SIN                                    | B3                        | -       
 *  PTD2                     | SPI0_SOUT                                   | C2                        | LCD_sin       
 *  PTB18                    | TSI0_CH11                                   | D6                        | Touch 1       
 *  PTB19                    | TSI0_CH12                                   | C7                        | Touch 2       
 *  PTB16                    | UART0_RX                                    | E6                        | USB_serial       
 *  PTB17                    | UART0_TX                                    | D7                        | USB_serial       
 *  USB0_DM                  | USB0_DM                                     | D1                        | Reserved(USB_DM)       
 *  USB0_DP                  | USB0_DP                                     | E1                        | Reserved(USB_DP)       
 *  VBAT                     | VBAT                                        | H5                        | -       
 *  VDD1                     | VDD1                                        | C5                        | -       
 *  VDD2                     | VDD2                                        | G7                        | -       
 *  VDD3                     | VDD3                                        | E4                        | -       
 *  VDDA                     | VDDA                                        | F4                        | -       
 *  VOUT33                   | VOUT33                                      | E2                        | -       
 *  VREFH                    | VREFH                                       | G4                        | -       
 *  VREFL                    | VREFL                                       | G3                        | -       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5                  | H1                        | -       
 *  VREGIN                   | VREGIN                                      | D2                        | -       
 *  VSS1                     | VSS1                                        | C4                        | -       
 *  VSS2                     | VSS2                                        | H7                        | -       
 *  VSS3                     | VSS3                                        | E3                        | -       
 *  VSSA                     | VSSA                                        | F3                        | -       
 *  PTA19                    | XTAL0                                       | G8                        | Reserved       
 *  XTAL32                   | XTAL32                                      | H3                        | Reserved(XTAL32)       
 *
 */

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */

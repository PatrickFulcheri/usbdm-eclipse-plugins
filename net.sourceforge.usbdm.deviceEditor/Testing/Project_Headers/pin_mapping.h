/**
 * @file      pin_mapping.h (derived from MK66F18.usbdmHardware)
 * @version   1.2.0
 * @brief     Pin declarations for FRDM_K66F
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stddef.h>
#include "derivative.h"

#include "gpio.h"

/*
 * Common Mux settings for PCR
 */
#undef FIXED_ADC_FN            
#undef FIXED_GPIO_FN           
#undef FIXED_PORT_CLOCK_REG    
#define FIXED_ADC_FN             0                    // Fixed ADC Multiplexing value
#define FIXED_GPIO_FN            1                    // Fixed GPIO Multiplexing value
#define FIXED_PORT_CLOCK_REG     SCGC5                // Fixed PORT Clock

/*
 * Peripheral clock macros
 */
#define PORT_CLOCK_REG       SCGC5

namespace USBDM {

/** Class to static check signal mapping is valid */
template<class Info, int signalNum> class CheckSignal {
#ifdef DEBUG_BUILD
   static_assert((signalNum<Info::NUM_SIGNALS), "Non-existent signal - Modify Configure.usbdm");
   static_assert((signalNum>=Info::NUM_SIGNALS)||(Info::info[signalNum].gpioBit != UNMAPPED_PCR), "Signal is not mapped to a pin - Modify Configure.usbdm");
   static_assert((signalNum>=Info::NUM_SIGNALS)||(Info::info[signalNum].gpioBit != INVALID_PCR),  "Signal doesn't exist in this device/package");
   static_assert((signalNum>=Info::NUM_SIGNALS)||((Info::info[signalNum].gpioBit == UNMAPPED_PCR)||(Info::info[signalNum].gpioBit == INVALID_PCR)||(Info::info[signalNum].gpioBit >= 0)), "Illegal signal");
#endif
};

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Pins used for Analogue Input
 * @{
 */
#define USBDM_ADC0_IS_DEFINED 
/**
 * Peripheral information for ADC, Analogue Input
 */
class Adc0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = ADC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_ADC0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {ADC0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t CFG1  = 
       (3<<ADC_CFG1_ADICLK_SHIFT)|
       (1<<ADC_CFG1_MODE_SHIFT)|
       (0<<ADC_CFG1_ADLSMP_SHIFT)|
       (0<<ADC_CFG1_ADIV_SHIFT)|
       (0<<ADC_CFG1_ADLPC_SHIFT);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t CFG2  = 
        ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       (0<<ADC_CFG2_ADLSTS_SHIFT)|
       (0<<ADC_CFG2_ADHSC_SHIFT)|
       (0<<ADC_CFG2_ADACKEN_SHIFT);

   static constexpr uint32_t SC1  = 
       (0<<ADC_SC1_AIEN_SHIFT);

   static constexpr uint32_t SC2  =
       (0<<ADC_SC2_REFSEL_SHIFT)|
       (0<<ADC_SC2_DMAEN_SHIFT)|
       (0b000<<ADC_SC2_ACREN_SHIFT)|
       (0<<ADC_SC2_ADTRG_SHIFT);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  6;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 24;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   4: ADC0_SE4b       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: ADC0_SE5b       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: ADC0_SE6b       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: ADC0_SE7b       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: ADC0_SE8        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: ADC0_SE9        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: ADC0_SE10       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  11: ADC0_SE11       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  12: ADC0_SE12       = PTB2 (A5)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  2,   PORT_PCR_MUX(0)|pcrValue  },
         /*  13: ADC0_SE13       = PTB3 (A4)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  3,   PORT_PCR_MUX(0)|pcrValue  },
         /*  14: ADC0_SE14       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: ADC0_SE15       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  16: ADC0_SE16       = ADC0_SE16                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  17: ADC0_SE17       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  18: ADC0_SE18       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  19: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  20: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  21: ADC0_SE21       = ADC0_SE16                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  22: ADC0_SE22       = ADC1_SE16                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  23: ADC0_SE23       = DAC0_OUT                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Adc0Info, 12>::setPCR(); // ADC0_SE12       = PTB2 (A5)                     
      PcrTable_T<Adc0Info, 13>::setPCR(); // ADC0_SE13       = PTB3 (A4)                     
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Adc0Info, 12>::setPCR(0); // ADC0_SE12       = PTB2 (A5)                     
      PcrTable_T<Adc0Info, 13>::setPCR(0); // ADC0_SE13       = PTB3 (A4)                     
   }

   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   1: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   2: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC0_DP3        = ADC1_DP0                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC0_DM0        = ADC0_DM0                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   2: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC0_DM3        = ADC1_DM0                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_ADC1_IS_DEFINED 
/**
 * Peripheral information for ADC, Analogue Input
 */
class Adc1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = ADC1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC3_ADC1_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC3);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {ADC0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t CFG1  = 
       (0<<ADC_CFG1_ADICLK_SHIFT)|
       (0<<ADC_CFG1_MODE_SHIFT)|
       (0<<ADC_CFG1_ADLSMP_SHIFT)|
       (2<<ADC_CFG1_ADIV_SHIFT)|
       (0<<ADC_CFG1_ADLPC_SHIFT);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t CFG2  = 
        ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       (0<<ADC_CFG2_ADLSTS_SHIFT)|
       (0<<ADC_CFG2_ADHSC_SHIFT)|
       (0<<ADC_CFG2_ADACKEN_SHIFT);

   static constexpr uint32_t SC1  = 
       (0<<ADC_SC1_AIEN_SHIFT);

   static constexpr uint32_t SC2  =
       (0<<ADC_SC2_REFSEL_SHIFT)|
       (0<<ADC_SC2_DMAEN_SHIFT)|
       (0b000<<ADC_SC2_ACREN_SHIFT)|
       (0<<ADC_SC2_ADTRG_SHIFT);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 40;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   4: ADC1_SE4b       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: ADC1_SE5b       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: ADC1_SE6b       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: ADC1_SE7b       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: ADC1_SE8        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: ADC1_SE9        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: ADC1_SE10       = PTB4 (A3)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  4,   PORT_PCR_MUX(0)|pcrValue  },
         /*  11: ADC1_SE11       = PTB5 (A2)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  5,   PORT_PCR_MUX(0)|pcrValue  },
         /*  12: ADC1_SE12       = PTB6 (A1)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  6,   PORT_PCR_MUX(0)|pcrValue  },
         /*  13: ADC1_SE13       = PTB7 (A0)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  7,   PORT_PCR_MUX(0)|pcrValue  },
         /*  14: ADC1_SE14       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: ADC1_SE15       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  16: ADC1_SE16       = ADC1_SE16                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  17: ADC1_SE17       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  18: ADC1_SE18       = VREF_OUT                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  19: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  20: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  21: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  22: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  23: ADC1_SE23       = DAC1_OUT                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  24: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  25: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  26: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  27: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  28: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  29: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  30: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  31: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  32: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  33: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  34: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  35: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  36: ADC1_SE4a       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  37: ADC1_SE5a       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  38: ADC1_SE6a       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  39: ADC1_SE7a       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Adc1Info, 10>::setPCR(); // ADC1_SE10       = PTB4 (A3)                     
      PcrTable_T<Adc1Info, 11>::setPCR(); // ADC1_SE11       = PTB5 (A2)                     
      PcrTable_T<Adc1Info, 12>::setPCR(); // ADC1_SE12       = PTB6 (A1)                     
      PcrTable_T<Adc1Info, 13>::setPCR(); // ADC1_SE13       = PTB7 (A0)                     
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Adc1Info, 10>::setPCR(0); // ADC1_SE10       = PTB4 (A3)                     
      PcrTable_T<Adc1Info, 11>::setPCR(0); // ADC1_SE11       = PTB5 (A2)                     
      PcrTable_T<Adc1Info, 12>::setPCR(0); // ADC1_SE12       = PTB6 (A1)                     
      PcrTable_T<Adc1Info, 13>::setPCR(0); // ADC1_SE13       = PTB7 (A0)                     
   }

   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 1;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC1_DP0        = ADC1_DP0                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC1_DM0        = ADC1_DM0                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   2: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC1_DM3        = ADC0_DM0                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End ADC_Group
 * @}
 */
/**
 * @addtogroup CAN_Misc_Group CAN, CAN0 (Miscellaneous)
 * @brief Pins used for CAN0 (Miscellaneous)
 * @{
 */
/** 
 * End CAN_Misc_Group
 * @}
 */
/**
 * @addtogroup CLKOUT_Group CLKOUT, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End CLKOUT_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */
#define USBDM_CMP0_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator
 */
class Cmp0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CMP0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMP_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMP0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP0_IN0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: CMP0_IN1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: CMP0_IN2        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: CMP0_IN3        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: CMP0_IN4        = DAC1_OUT                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   5: CMP0_IN5        = VREF_OUT                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP0_OUT        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_CMP1_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator
 */
class Cmp1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CMP1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP1_IN0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: CMP1_IN1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: CMP1_IN2        = ADC0_SE16                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   3: CMP1_IN3        = DAC0_OUT                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   5: CMP1_IN5        = VREF_OUT                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP1_OUT        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_CMP2_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator
 */
class Cmp2Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CMP2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP2_IN0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: CMP2_IN1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: CMP2_IN2        = ADC1_SE16                      */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   3: CMP2_IN3        = DAC1_OUT                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   5: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   6: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP2_OUT        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_CMP3_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator
 */
class Cmp3Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CMP3_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: CMP3_IN1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: CMP3_IN2        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   4: CMP3_IN4        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: CMP3_IN5        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP3_OUT        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End CMP_Group
 * @}
 */
/**
 * @addtogroup CMT_Misc_Group CMT, CMT (Miscellaneous)
 * @brief Pins used for CMT (Miscellaneous)
 * @{
 */
#define USBDM_CMT_IS_DEFINED 
/**
 * Peripheral information for CMT, CMT (Miscellaneous)
 */
class CmtInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CMT_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMT_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End CMT_Misc_Group
 * @}
 */
/**
 * @addtogroup CRC_Misc_Group CRC, CRC (Miscellaneous)
 * @brief Pins used for CRC (Miscellaneous)
 * @{
 */
#define USBDM_CRC_IS_DEFINED 
/**
 * Peripheral information for CRC, CRC (Miscellaneous)
 */
class CrcInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = CRC_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_CRC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End CRC_Misc_Group
 * @}
 */
/**
 * @addtogroup DAC_Misc_Group DAC, DAC0 (Miscellaneous)
 * @brief Pins used for DAC0 (Miscellaneous)
 * @{
 */
#define USBDM_DAC0_IS_DEFINED 
/**
 * Peripheral information for DAC, DAC0 (Miscellaneous)
 */
class Dac0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = DAC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_DAC0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {DAC0_IRQn, DAC0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

#define USBDM_DAC1_IS_DEFINED 
/**
 * Peripheral information for DAC, DAC1 (Miscellaneous)
 */
class Dac1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = DAC1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC2_DAC1_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC2);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {DAC1_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End DAC_Misc_Group
 * @}
 */
/**
 * @addtogroup DMA_Misc_Group DMA, DMA0 (Miscellaneous)
 * @brief Pins used for DMA0 (Miscellaneous)
 * @{
 */
#define USBDM_DMA0_IS_DEFINED 
/**
 * Peripheral information for DMA, DMA0 (Miscellaneous)
 */
class Dma0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = DMA0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC7_DMA_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC7);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End DMA_Misc_Group
 * @}
 */
/**
 * @addtogroup DMAMUX_Group DMAMUX, Direct Memory Access (DMA)
 * @brief Pins used for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMAMUX0_IS_DEFINED 
/**
 * Peripheral information for DMAMUX, Direct Memory Access (DMA)
 */
class Dmamux0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = DMAMUX0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_DMAMUX0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   /* DMA channel numbers */
   enum DmaChannels {
      DMA0_SLOT_Disabled                            = 0,
      DMA0_SLOT_TSI0                                = 1,
      DMA0_SLOT_UART0_Receive                       = 2,
      DMA0_SLOT_UART0_Transmit                      = 3,
      DMA0_SLOT_UART1_Receive                       = 4,
      DMA0_SLOT_UART1_Transmit                      = 5,
      DMA0_SLOT_UART2_Receive                       = 6,
      DMA0_SLOT_UART2_Transmit                      = 7,
      DMA0_SLOT_UART3_Receive                       = 8,
      DMA0_SLOT_UART3_Transmit                      = 9,
      DMA0_SLOT_UART4_TransmitReceive               = 10,
      DMA0_SLOT_I2S0_Receive                        = 12,
      DMA0_SLOT_I2S0_Transmit                       = 13,
      DMA0_SLOT_SPI0_Receive                        = 14,
      DMA0_SLOT_SPI0_Transmit                       = 15,
      DMA0_SLOT_SPI1_TransmitReceive                = 16,
      DMA0_SLOT_SPI2_TransmitReceive                = 17,
      DMA0_SLOT_I2C0_I2C3                           = 18,
      DMA0_SLOT_I2C1_I2C2                           = 19,
      DMA0_SLOT_FTM0_Ch_0                           = 20,
      DMA0_SLOT_FTM0_Ch_1                           = 21,
      DMA0_SLOT_FTM0_Ch_2                           = 22,
      DMA0_SLOT_FTM0_Ch_3                           = 23,
      DMA0_SLOT_FTM0_Ch_4                           = 24,
      DMA0_SLOT_FTM0_Ch_5                           = 25,
      DMA0_SLOT_FTM0_Ch_6                           = 26,
      DMA0_SLOT_FTM0_Ch_7                           = 27,
      DMA0_SLOT_FTM1_Ch_0                           = 28,
      DMA0_SLOT_TPM1_Ch_0                           = 28,
      DMA0_SLOT_FTM1_Ch_1                           = 29,
      DMA0_SLOT_TPM1_Ch_1                           = 29,
      DMA0_SLOT_FTM2_Ch_0                           = 30,
      DMA0_SLOT_TPM2_Ch_0                           = 30,
      DMA0_SLOT_FTM2_Ch_1                           = 31,
      DMA0_SLOT_TPM2_Ch_1                           = 31,
      DMA0_SLOT_FTM3_Ch_0                           = 32,
      DMA0_SLOT_FTM3_Ch_1                           = 33,
      DMA0_SLOT_FTM3_Ch_2                           = 34,
      DMA0_SLOT_FTM3_Ch_3                           = 35,
      DMA0_SLOT_FTM3_Ch_4                           = 36,
      DMA0_SLOT_FTM3_Ch_5                           = 37,
      DMA0_SLOT_FTM3_Ch_6                           = 38,
      DMA0_SLOT_SPI2_Rx                             = 38,
      DMA0_SLOT_FTM3_Ch_7                           = 39,
      DMA0_SLOT_SPI2_Tx                             = 39,
      DMA0_SLOT_ADC0                                = 40,
      DMA0_SLOT_ADC1                                = 41,
      DMA0_SLOT_CMP0                                = 42,
      DMA0_SLOT_CMP1                                = 43,
      DMA0_SLOT_CMP2                                = 44,
      DMA0_SLOT_CMP3                                = 44,
      DMA0_SLOT_DAC0                                = 45,
      DMA0_SLOT_DAC1                                = 46,
      DMA0_SLOT_CMT                                 = 47,
      DMA0_SLOT_PDB                                 = 48,
      DMA0_SLOT_PortA                               = 49,
      DMA0_SLOT_PortB                               = 50,
      DMA0_SLOT_PortC                               = 51,
      DMA0_SLOT_PortD                               = 52,
      DMA0_SLOT_PortE                               = 53,
      DMA0_SLOT_IEEE1588_Timer0                     = 54,
      DMA0_SLOT_IEEE1588_Timer1                     = 55,
      DMA0_SLOT_IEEE1588_Timer2                     = 56,
      DMA0_SLOT_IEEE1588_Timer3                     = 57,
      DMA0_SLOT_LPUART0_Rx                          = 58,
      DMA0_SLOT_LPUART0_Tx                          = 59,
      DMA0_SLOT_AlwaysEnabled2                      = 60,
      DMA0_SLOT_AlwaysEnabled3                      = 61,
      DMA0_SLOT_AlwaysEnabled4                      = 62,
      DMA0_SLOT_AlwaysEnabled5                      = 63,
   };
};

/** 
 * End DMAMUX_Group
 * @}
 */
/**
 * @addtogroup ENET_Misc_Group ENET, ENET (Miscellaneous)
 * @brief Pins used for ENET (Miscellaneous)
 * @{
 */
#define USBDM_ENET_IS_DEFINED 
/**
 * Peripheral information for ENET, ENET (Miscellaneous)
 */
class EnetInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = ENET_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC2_ENET_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC2);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 4;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {ENET_Transmit_IRQn, ENET_Receive_IRQn, ENET_Error_IRQn, ENET_1588Timeout_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End ENET_Misc_Group
 * @}
 */
/**
 * @addtogroup EWM_Misc_Group EWM, EWM (Miscellaneous)
 * @brief Pins used for EWM (Miscellaneous)
 * @{
 */
#define USBDM_EWM_IS_DEFINED 
/**
 * Peripheral information for EWM, EWM (Miscellaneous)
 */
class EwmInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = EWM_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_EWM_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End EWM_Misc_Group
 * @}
 */
/**
 * @addtogroup FB_Misc_Group FB, FB (Miscellaneous)
 * @brief Pins used for FB (Miscellaneous)
 * @{
 */
#define USBDM_FB_IS_DEFINED  
/**
 * Peripheral information for FB, FB (Miscellaneous)
 */
class FbInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = FB_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC7_FLEXBUS_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC7);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End FB_Misc_Group
 * @}
 */
/**
 * @addtogroup FLEXCAN0_Group FLEXCAN0, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End FLEXCAN0_Group
 * @}
 */
/**
 * @addtogroup FLEXCAN1_Group FLEXCAN1, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End FLEXCAN1_Group
 * @}
 */
/**
 * @addtogroup FTFE_Misc_Group FTFE, FTFE (Miscellaneous)
 * @brief Pins used for FTFE (Miscellaneous)
 * @{
 */
#define USBDM_FTFE_IS_DEFINED 
/**
 * Peripheral information for FTFE, FTFE (Miscellaneous)
 */
class FtfeInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = FTFE_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTF_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End FTFE_Misc_Group
 * @}
 */
/**
 * @addtogroup FTM_Misc_Group FTM, FTM (Miscellaneous)
 * @brief Pins used for FTM (Miscellaneous)
 * @{
 */
/** 
 * End FTM_Misc_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */
#define USBDM_FTM0_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = FTM0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for SC register
   static constexpr uint32_t SC  = 
       (0<<FTM_SC_CPWMS_SHIFT)|
       ((0|0)<<FTM_SC_TOIE_SHIFT)|
       FTM_SC_CLKS(1)|
       FTM_SC_PS(0);

   //! Default Timer Period
   static constexpr uint32_t PERIOD =  10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM0_CH0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM0_CH1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: FTM0_CH2        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: FTM0_CH3        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: FTM0_CH4        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: FTM0_CH5        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: FTM0_CH6        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: FTM0_CH7        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM0_FLT0       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM0_FLT1       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   2: FTM0_FLT2       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   3: FTM0_FLT3       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM1_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = FTM1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM1_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM1_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for SC register
   static constexpr uint32_t SC  = 
       (0<<FTM_SC_CPWMS_SHIFT)|
       ((0|0)<<FTM_SC_TOIE_SHIFT)|
       FTM_SC_CLKS(1)|
       FTM_SC_PS(0);

   //! Default Timer Period
   static constexpr uint32_t PERIOD =  10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM1_CH0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM1_CH1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 1;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM1_FLT0       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 2;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM1_QD_PHA     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM1_QD_PHB     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM2_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm2Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = FTM2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM2_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM3_IRQn, FTM2_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for SC register
   static constexpr uint32_t SC  = 
       (0<<FTM_SC_CPWMS_SHIFT)|
       ((0|0)<<FTM_SC_TOIE_SHIFT)|
       FTM_SC_CLKS(1)|
       FTM_SC_PS(0);

   //! Default Timer Period
   static constexpr uint32_t PERIOD =  10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM2_CH0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM2_CH1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 1;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM2_FLT0       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 2;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM2_QD_PHA     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM2_QD_PHB     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM3_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare
 */
class Ftm3Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = FTM3_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC3_FTM3_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC3);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM3_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for SC register
   static constexpr uint32_t SC  = 
       (0<<FTM_SC_CPWMS_SHIFT)|
       ((0|0)<<FTM_SC_TOIE_SHIFT)|
       FTM_SC_CLKS(1)|
       FTM_SC_PS(0);

   //! Default Timer Period
   static constexpr uint32_t PERIOD =  10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM3_CH0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM3_CH1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: FTM3_CH2        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: FTM3_CH3        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: FTM3_CH4        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: FTM3_CH5        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: FTM3_CH6        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: FTM3_CH7        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int NUM_SIGNALS  = 1;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM3_FLT0       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       */
      static void initPCRs() {
      }

      /**
       * Initialise pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End FTM_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Pins used for Digital Input/Output
 * @{
 */
#define USBDM_GPIOA_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioAInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTA_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOA_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTA_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTA_IRQn};

};

#define USBDM_GPIOB_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioBInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTB_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOB_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTB_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTB_IRQn};

};

#define USBDM_GPIOC_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioCInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTC_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOC_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTC_IRQn};

};

#define USBDM_GPIOD_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioDInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTD_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOD_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTD_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTD_IRQn};

};

#define USBDM_GPIOE_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output
 */
class GpioEInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTE_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOE_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t pcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTE_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTE_IRQn};

};

/** 
 * End GPIO_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Pins used for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2C0_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface
 */
class I2c0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = I2C0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_I2C0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C0_SCL        = PTD8 (ONBOARD_SCL)             */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  8,   PORT_PCR_MUX(2)|pcrValue  },
         /*   1: I2C0_SDA        = PTD9 (ONBOARD_SDA)             */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  9,   PORT_PCR_MUX(2)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<I2c0Info,  0>::setPCR(); // I2C0_SCL        = PTD8 (ONBOARD_SCL)            
      PcrTable_T<I2c0Info,  1>::setPCR(); // I2C0_SDA        = PTD9 (ONBOARD_SDA)            
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<I2c0Info,  0>::setPCR(0); // I2C0_SCL        = PTD8 (ONBOARD_SCL)            
      PcrTable_T<I2c0Info,  1>::setPCR(0); // I2C0_SDA        = PTD9 (ONBOARD_SDA)            
   }

};

#define USBDM_I2C1_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface
 */
class I2c1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = I2C1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_I2C1_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C1_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C1_SCL        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2C1_SDA        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_I2C2_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface
 */
class I2c2Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = I2C2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC1_I2C2_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC1);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C2_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C2_SCL        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2C2_SDA        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_I2C3_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface
 */
class I2c3Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = I2C3_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC1_I2C3_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC1);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C3_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C3_SCL        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2C3_SDA        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End I2C_Group
 * @}
 */
/**
 * @addtogroup I2S_Group I2S, Inter-Integrated-Circuit Interface
 * @brief Pins used for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2S0_IS_DEFINED 
/**
 * Peripheral information for I2S, Inter-Integrated-Circuit Interface
 */
class I2s0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = I2S0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_I2S_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2S0_Tx_IRQn, I2S0_Rx_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 5;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2S0_MCLK       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2S0_RX_BCLK    = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: I2S0_RX_FS      = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: I2S0_TX_BCLK    = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: I2S0_TX_FS      = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End I2S_Group
 * @}
 */
/**
 * @addtogroup JTAG_Group JTAG, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End JTAG_Group
 * @}
 */
/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Pins used for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_LLWU_IS_DEFINED 
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit
 */
class LlwuInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = LLWU_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 26;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: LLWU_P0         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: LLWU_P1         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: LLWU_P2         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: LLWU_P3         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: LLWU_P4         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: LLWU_P5         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: LLWU_P6         = PTC1 (D18)                     */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  1,   PORT_PCR_MUX(1)|pcrValue  },
         /*   7: LLWU_P7         = PTC3 (D0)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  3,   PORT_PCR_MUX(1)|pcrValue  },
         /*   8: LLWU_P8         = PTC4 (D1)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  4,   PORT_PCR_MUX(1)|pcrValue  },
         /*   9: LLWU_P9         = PTC5 (D5)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  5,   PORT_PCR_MUX(1)|pcrValue  },
         /*  10: LLWU_P10        = PTC6 (D19)                     */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  6,   PORT_PCR_MUX(1)|pcrValue  },
         /*  11: LLWU_P11        = PTC11 (D14)                    */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  11,  PORT_PCR_MUX(1)|pcrValue  },
         /*  12: LLWU_P12        = PTD0 (D10)                     */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  0,   PORT_PCR_MUX(1)|pcrValue  },
         /*  13: LLWU_P13        = PTD2 (D11)                     */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  2,   PORT_PCR_MUX(1)|pcrValue  },
         /*  14: LLWU_P14        = PTD4 (nRF_cs_n)                */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  4,   PORT_PCR_MUX(1)|pcrValue  },
         /*  15: LLWU_P15        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  16: LLWU_P16        = PTE6 (LED_GREEN)               */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  6,   PORT_PCR_MUX(1)|pcrValue  },
         /*  17: LLWU_P17        = PTE9 (D20)                     */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  9,   PORT_PCR_MUX(1)|pcrValue  },
         /*  18: LLWU_P18        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  19: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  20: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  21: LLWU_P21        = PTE25 (D31)                    */  { PORTE_CLOCK_MASK, PORTE_BasePtr,  GPIOE_BasePtr,  25,  PORT_PCR_MUX(1)|pcrValue  },
         /*  22: LLWU_P22        = PTA10 (SW3)                    */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  10,  PORT_PCR_MUX(1)|pcrValue  },
         /*  23: LLWU_P23        = PTA11 (LED_BLUE)               */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  11,  PORT_PCR_MUX(1)|pcrValue  },
         /*  24: LLWU_P24        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  25: LLWU_P25        = PTD11 (SW2)                    */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  11,  PORT_PCR_MUX(1)|pcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<LlwuInfo,  6>::setPCR(); // LLWU_P6         = PTC1 (D18)                    
      PcrTable_T<LlwuInfo,  7>::setPCR(); // LLWU_P7         = PTC3 (D0)                     
      PcrTable_T<LlwuInfo,  8>::setPCR(); // LLWU_P8         = PTC4 (D1)                     
      PcrTable_T<LlwuInfo,  9>::setPCR(); // LLWU_P9         = PTC5 (D5)                     
      PcrTable_T<LlwuInfo, 10>::setPCR(); // LLWU_P10        = PTC6 (D19)                    
      PcrTable_T<LlwuInfo, 11>::setPCR(); // LLWU_P11        = PTC11 (D14)                   
      PcrTable_T<LlwuInfo, 12>::setPCR(); // LLWU_P12        = PTD0 (D10)                    
      PcrTable_T<LlwuInfo, 13>::setPCR(); // LLWU_P13        = PTD2 (D11)                    
      PcrTable_T<LlwuInfo, 14>::setPCR(); // LLWU_P14        = PTD4 (nRF_cs_n)               
      PcrTable_T<LlwuInfo, 16>::setPCR(); // LLWU_P16        = PTE6 (LED_GREEN)              
      PcrTable_T<LlwuInfo, 17>::setPCR(); // LLWU_P17        = PTE9 (D20)                    
      PcrTable_T<LlwuInfo, 21>::setPCR(); // LLWU_P21        = PTE25 (D31)                   
      PcrTable_T<LlwuInfo, 22>::setPCR(); // LLWU_P22        = PTA10 (SW3)                   
      PcrTable_T<LlwuInfo, 23>::setPCR(); // LLWU_P23        = PTA11 (LED_BLUE)              
      PcrTable_T<LlwuInfo, 25>::setPCR(); // LLWU_P25        = PTD11 (SW2)                   
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<LlwuInfo,  6>::setPCR(0); // LLWU_P6         = PTC1 (D18)                    
      PcrTable_T<LlwuInfo,  7>::setPCR(0); // LLWU_P7         = PTC3 (D0)                     
      PcrTable_T<LlwuInfo,  8>::setPCR(0); // LLWU_P8         = PTC4 (D1)                     
      PcrTable_T<LlwuInfo,  9>::setPCR(0); // LLWU_P9         = PTC5 (D5)                     
      PcrTable_T<LlwuInfo, 10>::setPCR(0); // LLWU_P10        = PTC6 (D19)                    
      PcrTable_T<LlwuInfo, 11>::setPCR(0); // LLWU_P11        = PTC11 (D14)                   
      PcrTable_T<LlwuInfo, 12>::setPCR(0); // LLWU_P12        = PTD0 (D10)                    
      PcrTable_T<LlwuInfo, 13>::setPCR(0); // LLWU_P13        = PTD2 (D11)                    
      PcrTable_T<LlwuInfo, 14>::setPCR(0); // LLWU_P14        = PTD4 (nRF_cs_n)               
      PcrTable_T<LlwuInfo, 16>::setPCR(0); // LLWU_P16        = PTE6 (LED_GREEN)              
      PcrTable_T<LlwuInfo, 17>::setPCR(0); // LLWU_P17        = PTE9 (D20)                    
      PcrTable_T<LlwuInfo, 21>::setPCR(0); // LLWU_P21        = PTE25 (D31)                   
      PcrTable_T<LlwuInfo, 22>::setPCR(0); // LLWU_P22        = PTA10 (SW3)                   
      PcrTable_T<LlwuInfo, 23>::setPCR(0); // LLWU_P23        = PTA11 (LED_BLUE)              
      PcrTable_T<LlwuInfo, 25>::setPCR(0); // LLWU_P25        = PTD11 (SW2)                   
   }

};

/** 
 * End LLWU_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Pins used for Low Power Timer
 * @{
 */
#define USBDM_LPTMR0_IS_DEFINED 
/**
 * Peripheral information for LPTMR, Low Power Timer
 */
class Lptmr0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = LPTMR0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_LPTMR_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LPTMR0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default PSR value
   static constexpr uint32_t PSR = 
      LPTMR_PSR_PRESCALE(0)|
      LPTMR_PSR_PCS(0)|
      (0<<LPTMR_PSR_PBYP_SHIFT)|
      (0<<LPTMR_PSR_PCS_SHIFT);

   //! Default CSR value
   static constexpr uint32_t CSR = 
      (0<<LPTMR_CSR_TIE_SHIFT)|
      (0<<LPTMR_CSR_TMS_SHIFT)|
      (0<<LPTMR_CSR_TFC_SHIFT)|
      (0<<LPTMR_CSR_TPP_SHIFT)|
      LPTMR_CSR_TPS(0);

   //! Default Timer period
   static constexpr uint32_t PERIOD = 10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 3;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --              = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: LPTMR0_ALT1     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: LPTMR0_ALT2     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End LPTMR_Group
 * @}
 */
/**
 * @addtogroup LPUART_Group LPUART, Low Power Universal Asynchonous Receiver/Transmitter
 * @brief Pins used for Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_LPUART0_IS_DEFINED 
/**
 * Peripheral information for LPUART, Low Power Universal Asynchonous Receiver/Transmitter
 */
class Lpuart0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = LPUART0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC2_LPUART0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC2);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LPUART0_RX_TX_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: LPUART0_TX      = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: LPUART0_RX      = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: LPUART0_RTS_b   = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: LPUART0_CTS_b   = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End LPUART_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Pins used for Multipurpose Clock Generator
 * @{
 */
#define USBDM_MCG_IS_DEFINED 
/**
 * Peripheral information for MCG, Multipurpose Clock Generator
 */
class McgInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = MCG_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

};

/** 
 * End MCG_Group
 * @}
 */
/**
 * @addtogroup MII_Misc_Group MII, MII0 (Miscellaneous)
 * @brief Pins used for MII0 (Miscellaneous)
 * @{
 */
/** 
 * End MII_Misc_Group
 * @}
 */
/**
 * @addtogroup MPU_Misc_Group MPU, MPU (Miscellaneous)
 * @brief Pins used for MPU (Miscellaneous)
 * @{
 */
#define USBDM_MPU_IS_DEFINED 
/**
 * Peripheral information for MPU, MPU (Miscellaneous)
 */
class MpuInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = MPU_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC7_MPU_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC7);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End MPU_Misc_Group
 * @}
 */
/**
 * @addtogroup NMI_B_Group NMI_b, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End NMI_B_Group
 * @}
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Pins used for Crystal Oscillator
 * @{
 */
#define USBDM_OSC0_IS_DEFINED 
/**
 * Peripheral information for OSC, Crystal Oscillator
 */
class Osc0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = OSC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! External Reference Enable
   static constexpr uint32_t CR_ERCLKEN_M  = (0<<OSC_CR_ERCLKEN_SHIFT);

   //! External Reference Stop Enable
   static constexpr uint32_t CR_EREFSTEN_M = (0<<OSC_CR_EREFSTEN_SHIFT);

   //! Oscillator load capacitance
   static constexpr uint32_t CR_SCP_M      = (2<<OSC_CR_SC16P_SHIFT);

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: XTAL0           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: EXTAL0          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End OSC_Group
 * @}
 */
/**
 * @addtogroup PDB_Misc_Group PDB, PDB0 (Miscellaneous)
 * @brief Pins used for PDB0 (Miscellaneous)
 * @{
 */
#define USBDM_PDB0_IS_DEFINED 
/**
 * Peripheral information for PDB, PDB0 (Miscellaneous)
 */
class Pdb0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = PDB0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_PDB_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PDB0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End PDB_Misc_Group
 * @}
 */
/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Pins used for Programmable Interrupt Timer
 * @{
 */
#define USBDM_PIT_IS_DEFINED 
/**
 * Peripheral information for PIT, Programmable Interrupt Timer
 */
class PitInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = PIT_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_PIT_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 4;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PIT0_IRQn, PIT1_IRQn, PIT2_IRQn, PIT3_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for PIT->SC register
   static constexpr uint32_t loadValue  = 65535;

   //! PIT operation in debug mode
   static constexpr uint32_t mcrValue = (0<<PIT_MCR_FRZ_SHIFT);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

};

/** 
 * End PIT_Group
 * @}
 */
/**
 * @addtogroup POWER_Misc_Group POWER, POWER (Miscellaneous)
 * @brief Pins used for POWER (Miscellaneous)
 * @{
 */
/** 
 * End POWER_Misc_Group
 * @}
 */
/**
 * @addtogroup RESET_B_Group RESET_b, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End RESET_B_Group
 * @}
 */
/**
 * @addtogroup RNG_Group RNG, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End RNG_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Pins used for Real Time Clock
 * @{
 */
#define USBDM_RTC_IS_DEFINED 
/**
 * Peripheral information for RTC, Real Time Clock
 */
class RtcInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = RTC_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_RTC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {RTC_Alarm_IRQn, RTC_Seconds_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! RTC Oscillator Enable
   static constexpr uint32_t CR_OSCE_M  = (0<<RTC_CR_OSCE_SHIFT);

   //!  RTC 32kHz Clock Output
   static constexpr uint32_t CR_CLKO_M  = (0<<RTC_CR_CLKO_SHIFT);

   //! Update Mode
   static constexpr uint32_t CR_UM_M    = (0<<RTC_CR_UM_SHIFT);

   //! Supervisor Access
   static constexpr uint32_t CR_SUP_M   = (0<<RTC_CR_SUP_SHIFT);

   //! Wakeup Pin Enable
   static constexpr uint32_t CR_WPE_M   = (0<<RTC_CR_WPE_SHIFT);

   //! Oscillator load capacitance
   static constexpr uint32_t CR_SCP_M   = (2<<RTC_CR_SC16P_SHIFT);

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 3;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: XTAL32          = XTAL32                         */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: EXTAL32         = EXTAL32                        */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: RTC_CLKOUT      = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End RTC_Group
 * @}
 */
/**
 * @addtogroup RTC_WAKEUP_B_Group RTC_WAKEUP_B, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End RTC_WAKEUP_B_Group
 * @}
 */
/**
 * @addtogroup SDHC_Group SDHC, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End SDHC_Group
 * @}
 */
/**
 * @addtogroup SDHC_Misc_Group SDHC, SDHC0 (Miscellaneous)
 * @brief Pins used for SDHC0 (Miscellaneous)
 * @{
 */
/** 
 * End SDHC_Misc_Group
 * @}
 */
/**
 * @addtogroup SDRAM_Misc_Group SDRAM, SDRAM (Miscellaneous)
 * @brief Pins used for SDRAM (Miscellaneous)
 * @{
 */
#define USBDM_SDRAM_IS_DEFINED 
/**
 * Peripheral information for SDRAM, SDRAM (Miscellaneous)
 */
class SdramInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = SDRAM_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC7_SDRAMC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC7);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End SDRAM_Misc_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Pins used for Serial Peripheral Interface
 * @{
 */
#define USBDM_SPI0_IS_DEFINED 
/**
 * Peripheral information for SPI, Serial Peripheral Interface
 */
class Spi0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = SPI0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_SPI0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {SPI0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

#ifdef SPI_CTAR_LSBFE_SHIFT
   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint32_t modeValue = (0<<SPI_CTAR_LSBFE_SHIFT)|(0<<SPI_CTAR_CPHA_SHIFT);

#endif
   //! Default speed (Hz)
   static constexpr uint32_t speed = 100000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SPI0_SCK        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: SPI0_SIN        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: SPI0_SOUT       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: SPI0_PCS0       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: SPI0_PCS1       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: SPI0_PCS2       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: SPI0_PCS3       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: SPI0_PCS4       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: SPI0_PCS5       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_SPI1_IS_DEFINED 
/**
 * Peripheral information for SPI, Serial Peripheral Interface
 */
class Spi1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = SPI1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_SPI1_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {SPI1_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

#ifdef SPI_CTAR_LSBFE_SHIFT
   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint32_t modeValue = (0<<SPI_CTAR_LSBFE_SHIFT)|(0<<SPI_CTAR_CPHA_SHIFT);

#endif
   //! Default speed (Hz)
   static constexpr uint32_t speed = 100000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 7;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SPI1_SCK        = PTD5 (nRF_sck)                 */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  5,   PORT_PCR_MUX(7)|pcrValue  },
         /*   1: SPI1_SIN        = PTD7 (nRF_miso)                */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  7,   PORT_PCR_MUX(7)|pcrValue  },
         /*   2: SPI1_SOUT       = PTD6 (nRF_mosi)                */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  6,   PORT_PCR_MUX(7)|pcrValue  },
         /*   3: SPI1_PCS0       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: SPI1_PCS1       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: SPI1_PCS2       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: SPI1_PCS3       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Spi1Info,  0>::setPCR(); // SPI1_SCK        = PTD5 (nRF_sck)                
      PcrTable_T<Spi1Info,  1>::setPCR(); // SPI1_SIN        = PTD7 (nRF_miso)               
      PcrTable_T<Spi1Info,  2>::setPCR(); // SPI1_SOUT       = PTD6 (nRF_mosi)               
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Spi1Info,  0>::setPCR(0); // SPI1_SCK        = PTD5 (nRF_sck)                
      PcrTable_T<Spi1Info,  1>::setPCR(0); // SPI1_SIN        = PTD7 (nRF_miso)               
      PcrTable_T<Spi1Info,  2>::setPCR(0); // SPI1_SOUT       = PTD6 (nRF_mosi)               
   }

};

#define USBDM_SPI2_IS_DEFINED 
/**
 * Peripheral information for SPI, Serial Peripheral Interface
 */
class Spi2Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = SPI2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC3_SPI2_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC3);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {SPI2_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

#ifdef SPI_CTAR_LSBFE_SHIFT
   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint32_t modeValue = (0<<SPI_CTAR_LSBFE_SHIFT)|(0<<SPI_CTAR_CPHA_SHIFT);

#endif
   //! Default speed (Hz)
   static constexpr uint32_t speed = 100000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 5;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SPI2_SCK        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: SPI2_SIN        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: SPI2_SOUT       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: SPI2_PCS0       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: SPI2_PCS1       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End SPI_Group
 * @}
 */
/**
 * @addtogroup SWD_Group SWD, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End SWD_Group
 * @}
 */
/**
 * @addtogroup TPM_Misc_Group TPM, TPM (Miscellaneous)
 * @brief Pins used for TPM (Miscellaneous)
 * @{
 */
/** 
 * End TPM_Misc_Group
 * @}
 */
/**
 * @addtogroup TPM_Group TPM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */
#define USBDM_TPM1_IS_DEFINED 
/**
 * Peripheral information for TPM, PWM, Input capture and Output compare
 */
class Tpm1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = TPM1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC2_TPM1_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC2);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {TPM1_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for SC register
   static constexpr uint32_t SC  = 
       (0<<TPM_SC_TOIE_SHIFT)|
       TPM_SC_CMOD(1)|
       TPM_SC_PS(0);

   //! Default Timer Period
   static constexpr uint32_t PERIOD =  10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: TPM1_CH0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: TPM1_CH1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_TPM2_IS_DEFINED 
/**
 * Peripheral information for TPM, PWM, Input capture and Output compare
 */
class Tpm2Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = TPM2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC2_TPM2_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC2);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {TPM2_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Default value for SC register
   static constexpr uint32_t SC  = 
       (0<<TPM_SC_TOIE_SHIFT)|
       TPM_SC_CMOD(1)|
       TPM_SC_PS(0);

   //! Default Timer Period
   static constexpr uint32_t PERIOD =  10000;

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: TPM2_CH0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: TPM2_CH1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End TPM_Group
 * @}
 */
/**
 * @addtogroup TRACE_Group TRACE, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End TRACE_Group
 * @}
 */
/**
 * @addtogroup TSI_Group TSI, Misc
 * @brief Pins used for Misc
 * @{
 */
#define USBDM_TSI0_IS_DEFINED 
/**
 * Peripheral information for TSI, Low-leakage Wake-up Unit
 */
class Tsi0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = TSI0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 16;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: TSI0_CH0        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: TSI0_CH1        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: TSI0_CH2        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: TSI0_CH3        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: TSI0_CH4        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: TSI0_CH5        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: TSI0_CH6        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: TSI0_CH7        = PTB2 (A5)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  2,   PORT_PCR_MUX(0)|pcrValue  },
         /*   8: TSI0_CH8        = PTB3 (A4)                      */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  3,   PORT_PCR_MUX(0)|pcrValue  },
         /*   9: TSI0_CH9        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: TSI0_CH10       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  11: TSI0_CH11       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  12: TSI0_CH12       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  13: TSI0_CH13       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  14: TSI0_CH14       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: TSI0_CH15       = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Tsi0Info,  7>::setPCR(); // TSI0_CH7        = PTB2 (A5)                     
      PcrTable_T<Tsi0Info,  8>::setPCR(); // TSI0_CH8        = PTB3 (A4)                     
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Tsi0Info,  7>::setPCR(0); // TSI0_CH7        = PTB2 (A5)                     
      PcrTable_T<Tsi0Info,  8>::setPCR(0); // TSI0_CH8        = PTB3 (A4)                     
   }

};

/** 
 * End TSI_Group
 * @}
 */
/**
 * @addtogroup UART_Group UART, Universal Asynchronous Receiver/Transmitter
 * @brief Pins used for Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_UART0_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = UART0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART0_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART0_RX_TX_IRQn, UART0_ERR_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 5;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART0_TX        = PTB17 (ConTx)                  */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  17,  PORT_PCR_MUX(3)|pcrValue  },
         /*   1: UART0_RX        = PTB16 (ConRx)                  */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  16,  PORT_PCR_MUX(3)|pcrValue  },
         /*   2: UART0_RTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART0_CTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: UART0_COL_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Uart0Info,  0>::setPCR(); // UART0_TX        = PTB17 (ConTx)                 
      PcrTable_T<Uart0Info,  1>::setPCR(); // UART0_RX        = PTB16 (ConRx)                 
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Uart0Info,  0>::setPCR(0); // UART0_TX        = PTB17 (ConTx)                 
      PcrTable_T<Uart0Info,  1>::setPCR(0); // UART0_RX        = PTB16 (ConRx)                 
   }

};

#define USBDM_UART1_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart1Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = UART1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART1_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART1_RX_TX_IRQn, UART1_ERR_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART1_TX        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART1_RX        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: UART1_RTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART1_CTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_UART2_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart2Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = UART2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART2_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART2_RX_TX_IRQn, UART2_ERR_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemBusClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART2_TX        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART2_RX        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: UART2_RTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART2_CTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_UART3_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart3Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = UART3_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART3_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART3_RX_TX_IRQn, UART3_ERR_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemBusClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART3_TX        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART3_RX        = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: UART3_RTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART3_CTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_UART4_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter
 */
class Uart4Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = UART4_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC1_UART4_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC1);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART4_RX_TX_IRQn, UART4_ERR_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemBusClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART4_TX        = PTC15 (BLUETOOTH_Tx)           */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  15,  PORT_PCR_MUX(3)|pcrValue  },
         /*   1: UART4_RX        = PTC14 (BLUETOOTH_Rx)           */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  14,  PORT_PCR_MUX(3)|pcrValue  },
         /*   2: UART4_RTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART4_CTS_b     = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
      PcrTable_T<Uart4Info,  0>::setPCR(); // UART4_TX        = PTC15 (BLUETOOTH_Tx)          
      PcrTable_T<Uart4Info,  1>::setPCR(); // UART4_RX        = PTC14 (BLUETOOTH_Rx)          
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
      PcrTable_T<Uart4Info,  0>::setPCR(0); // UART4_TX        = PTC15 (BLUETOOTH_Tx)          
      PcrTable_T<Uart4Info,  1>::setPCR(0); // UART4_RX        = PTC14 (BLUETOOTH_Rx)          
   }

};

/** 
 * End UART_Group
 * @}
 */
/**
 * @addtogroup USB_Misc_Group USB, USB0 (Miscellaneous)
 * @brief Pins used for USB0 (Miscellaneous)
 * @{
 */
#define USBDM_USB0_IS_DEFINED 
/**
 * Peripheral information for USB, USB0 (Miscellaneous)
 */
class Usb0Info {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = USB0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_USBOTG_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {USBHS_IRQn, USB0_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End USB_Misc_Group
 * @}
 */
/**
 * @addtogroup USBDCD_Misc_Group USBDCD, USBDCD (Miscellaneous)
 * @brief Pins used for USBDCD (Miscellaneous)
 * @{
 */
#define USBDM_USBDCD_IS_DEFINED 
/**
 * Peripheral information for USBDCD, USBDCD (Miscellaneous)
 */
class UsbdcdInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = USBDCD_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_USBDCD_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC6);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {USBDCD_IRQn};

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

};

/** 
 * End USBDCD_Misc_Group
 * @}
 */
/**
 * @addtogroup VBAT_Group VBAT, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End VBAT_Group
 * @}
 */
/**
 * @addtogroup VDDA_Group VDDA, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End VDDA_Group
 * @}
 */
/**
 * @addtogroup VREF_Group VREF, Voltage Reference
 * @brief Pins used for Voltage Reference
 * @{
 */
#define USBDM_VREF_IS_DEFINED 
/**
 * Peripheral information for VREF, Voltage Reference
 */
class VrefInfo {
public:
   //! Hardware base pointer
   static constexpr uint32_t basePtr   = VREF_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t pcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_VREF_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC4);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   //! Clock source for peripheral
   static constexpr uint32_t &clockSource = SystemCoreClock;

   //! Number of signals available in info table
   static constexpr int NUM_SIGNALS  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal            Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VREF_OUT        = VREF_OUT                       */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    */
   static void initPCRs() {
   }

   /**
    * Initialise pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End VREF_Group
 * @}
 */
/**
 * @addtogroup VREFH_Group VREFH, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End VREFH_Group
 * @}
 */
/**
 * @addtogroup VREFL_Group VREFL, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End VREFL_Group
 * @}
 */
/**
 * @addtogroup VREG_IN0_Group VREG_IN0, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End VREG_IN0_Group
 * @}
 */
/**
 * @addtogroup VREG_OUT_Group VREG_OUT, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End VREG_OUT_Group
 * @}
 */
/**
 * @addtogroup VSSA_Group VSSA, Misc
 * @brief Pins used for Misc
 * @{
 */
/** 
 * End VSSA_Group
 * @}
 */

} // End namespace USBDM

#include "adc.h"
#include "ftm.h"
#include "tpm.h"

namespace USBDM {

/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Pins used for Analogue Input
 * @{
 */
using adc_A5               = const USBDM::Adc0Channel<12>;
using adc_A4               = const USBDM::Adc0Channel<13>;
using adc_A3               = const USBDM::Adc1Channel<10>;
using adc_A2               = const USBDM::Adc1Channel<11>;
using adc_A1               = const USBDM::Adc1Channel<12>;
using adc_A0               = const USBDM::Adc1Channel<13>;
/** 
 * End ADC_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Pins used for Digital Input/Output
 * @{
 */
/**
 * @brief Convenience template for GpioA. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 3 of GpioA
 * GpioA<3> GpioA3
 *
 * // Set as digital output
 * GpioA3.setOutput();
 *
 * // Set pin high
 * GpioA3.set();
 *
 * // Set pin low
 * GpioA3.clear();
 *
 * // Toggle pin
 * GpioA3.toggle();
 *
 * // Set pin to boolean value
 * GpioA3.write(true);
 *
 * // Set pin to boolean value
 * GpioA3.write(false);
 *
 * // Set as digital input
 * GpioA3.setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioA3.read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 */
template<uint8_t bitNum> using GpioA = Gpio_T<GpioAInfo, bitNum>;

/**
 * @brief Convenience template for GpioA fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 6 down to 3 of GpioA
 * GpioAField<6,3> GpioA6_3
 *
 * // Set as digital output
 * GpioA6_3.setOutput();
 *
 * // Write value to field
 * GpioA6_3.write(0x53);
 *
 * // Clear all of field
 * GpioA6_3.bitClear();
 *
 * // Clear lower two bits of field
 * GpioA6_3.bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioA6_3.bitSet(0x3);
 *
 * // Set as digital input
 * GpioA6_3.setInput();
 *
 * // Read pin as int value
 * int x = GpioA6_3.read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 */
template<int left, int right> using GpioAField = Field_T<GpioAInfo, left, right>;

using gpio_SW3             = const USBDM::GpioA<10>;
using gpio_LED_BLUE        = const USBDM::GpioA<11>;
using gpio_D7              = const USBDM::GpioA<25>;
/**
 * @brief Convenience template for GpioB. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 3 of GpioB
 * GpioB<3> GpioB3
 *
 * // Set as digital output
 * GpioB3.setOutput();
 *
 * // Set pin high
 * GpioB3.set();
 *
 * // Set pin low
 * GpioB3.clear();
 *
 * // Toggle pin
 * GpioB3.toggle();
 *
 * // Set pin to boolean value
 * GpioB3.write(true);
 *
 * // Set pin to boolean value
 * GpioB3.write(false);
 *
 * // Set as digital input
 * GpioB3.setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioB3.read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 */
template<uint8_t bitNum> using GpioB = Gpio_T<GpioBInfo, bitNum>;

/**
 * @brief Convenience template for GpioB fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 6 down to 3 of GpioB
 * GpioBField<6,3> GpioB6_3
 *
 * // Set as digital output
 * GpioB6_3.setOutput();
 *
 * // Write value to field
 * GpioB6_3.write(0x53);
 *
 * // Clear all of field
 * GpioB6_3.bitClear();
 *
 * // Clear lower two bits of field
 * GpioB6_3.bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioB6_3.bitSet(0x3);
 *
 * // Set as digital input
 * GpioB6_3.setInput();
 *
 * // Read pin as int value
 * int x = GpioB6_3.read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 */
template<int left, int right> using GpioBField = Field_T<GpioBInfo, left, right>;

using gpio_D27             = const USBDM::GpioB<10>;
using gpio_D28             = const USBDM::GpioB<11>;
using gpio_D8              = const USBDM::GpioB<18>;
using gpio_D9              = const USBDM::GpioB<19>;
using gpio_nRF_ce_n        = const USBDM::GpioB<20>;
using gpio_A10             = const USBDM::GpioB<23>;
/**
 * @brief Convenience template for GpioC. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 3 of GpioC
 * GpioC<3> GpioC3
 *
 * // Set as digital output
 * GpioC3.setOutput();
 *
 * // Set pin high
 * GpioC3.set();
 *
 * // Set pin low
 * GpioC3.clear();
 *
 * // Toggle pin
 * GpioC3.toggle();
 *
 * // Set pin to boolean value
 * GpioC3.write(true);
 *
 * // Set pin to boolean value
 * GpioC3.write(false);
 *
 * // Set as digital input
 * GpioC3.setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioC3.read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 */
template<uint8_t bitNum> using GpioC = Gpio_T<GpioCInfo, bitNum>;

/**
 * @brief Convenience template for GpioC fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 6 down to 3 of GpioC
 * GpioCField<6,3> GpioC6_3
 *
 * // Set as digital output
 * GpioC6_3.setOutput();
 *
 * // Write value to field
 * GpioC6_3.write(0x53);
 *
 * // Clear all of field
 * GpioC6_3.bitClear();
 *
 * // Clear lower two bits of field
 * GpioC6_3.bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioC6_3.bitSet(0x3);
 *
 * // Set as digital input
 * GpioC6_3.setInput();
 *
 * // Read pin as int value
 * int x = GpioC6_3.read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 */
template<int left, int right> using GpioCField = Field_T<GpioCInfo, left, right>;

using gpio_D29             = const USBDM::GpioC<0>;
using gpio_D18             = const USBDM::GpioC<1>;
using gpio_D6              = const USBDM::GpioC<2>;
using gpio_D0              = const USBDM::GpioC<3>;
using gpio_D1              = const USBDM::GpioC<4>;
using gpio_D5              = const USBDM::GpioC<5>;
using gpio_D19             = const USBDM::GpioC<6>;
using gpio_D21             = const USBDM::GpioC<7>;
using gpio_D3              = const USBDM::GpioC<8>;
using gpio_LED_RED         = const USBDM::GpioC<9>;
using gpio_D15             = const USBDM::GpioC<10>;
using gpio_D14             = const USBDM::GpioC<11>;
using gpio_D4              = const USBDM::GpioC<12>;
using gpio_D2              = const USBDM::GpioC<16>;
using gpio_nRF_irq         = const USBDM::GpioC<18>;
/**
 * @brief Convenience template for GpioD. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 3 of GpioD
 * GpioD<3> GpioD3
 *
 * // Set as digital output
 * GpioD3.setOutput();
 *
 * // Set pin high
 * GpioD3.set();
 *
 * // Set pin low
 * GpioD3.clear();
 *
 * // Toggle pin
 * GpioD3.toggle();
 *
 * // Set pin to boolean value
 * GpioD3.write(true);
 *
 * // Set pin to boolean value
 * GpioD3.write(false);
 *
 * // Set as digital input
 * GpioD3.setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioD3.read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 */
template<uint8_t bitNum> using GpioD = Gpio_T<GpioDInfo, bitNum>;

/**
 * @brief Convenience template for GpioD fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 6 down to 3 of GpioD
 * GpioDField<6,3> GpioD6_3
 *
 * // Set as digital output
 * GpioD6_3.setOutput();
 *
 * // Write value to field
 * GpioD6_3.write(0x53);
 *
 * // Clear all of field
 * GpioD6_3.bitClear();
 *
 * // Clear lower two bits of field
 * GpioD6_3.bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioD6_3.bitSet(0x3);
 *
 * // Set as digital input
 * GpioD6_3.setInput();
 *
 * // Read pin as int value
 * int x = GpioD6_3.read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 */
template<int left, int right> using GpioDField = Field_T<GpioDInfo, left, right>;

using gpio_D10             = const USBDM::GpioD<0>;
using gpio_D13             = const USBDM::GpioD<1>;
using gpio_D11             = const USBDM::GpioD<2>;
using gpio_D12             = const USBDM::GpioD<3>;
using gpio_nRF_cs_n        = const USBDM::GpioD<4>;
using gpio_SW2             = const USBDM::GpioD<11>;
using gpio_D33             = const USBDM::GpioD<12>;
using gpio_D32             = const USBDM::GpioD<13>;
/**
 * @brief Convenience template for GpioE. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 3 of GpioE
 * GpioE<3> GpioE3
 *
 * // Set as digital output
 * GpioE3.setOutput();
 *
 * // Set pin high
 * GpioE3.set();
 *
 * // Set pin low
 * GpioE3.clear();
 *
 * // Toggle pin
 * GpioE3.toggle();
 *
 * // Set pin to boolean value
 * GpioE3.write(true);
 *
 * // Set pin to boolean value
 * GpioE3.write(false);
 *
 * // Set as digital input
 * GpioE3.setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioE3.read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 */
template<uint8_t bitNum> using GpioE = Gpio_T<GpioEInfo, bitNum>;

/**
 * @brief Convenience template for GpioE fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * // Instantiate for bit 6 down to 3 of GpioE
 * GpioEField<6,3> GpioE6_3
 *
 * // Set as digital output
 * GpioE6_3.setOutput();
 *
 * // Write value to field
 * GpioE6_3.write(0x53);
 *
 * // Clear all of field
 * GpioE6_3.bitClear();
 *
 * // Clear lower two bits of field
 * GpioE6_3.bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioE6_3.bitSet(0x3);
 *
 * // Set as digital input
 * GpioE6_3.setInput();
 *
 * // Read pin as int value
 * int x = GpioE6_3.read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 */
template<int left, int right> using GpioEField = Field_T<GpioEInfo, left, right>;

using gpio_LED_GREEN       = const USBDM::GpioE<6>;
using gpio_D23             = const USBDM::GpioE<7>;
using gpio_D22             = const USBDM::GpioE<8>;
using gpio_D20             = const USBDM::GpioE<9>;
using gpio_D17             = const USBDM::GpioE<11>;
using gpio_D16             = const USBDM::GpioE<12>;
using gpio_D30             = const USBDM::GpioE<24>;
using gpio_D31             = const USBDM::GpioE<25>;
/** 
 * End GPIO_Group
 * @}
 */
/**
 * Used to configure pin-mapping before 1st use of peripherals
 */
extern void mapAllPins();

} // End namespace USBDM
/**
 *
 * @mainpage Summary
 *
 * @section PinsByPinName Pins by Pin Name
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  ADC0_DM0                 | ADC0_DM0/ADC1_DM3                           |                           | -       
 *  ADC0_SE16                | ADC0_SE16/CMP1_IN2/ADC0_SE21                |                           | -       
 *  ADC1_DM0                 | ADC1_DM0/ADC0_DM3                           |                           | -       
 *  ADC1_DP0                 | ADC1_DP0/ADC0_DP3                           |                           | -       
 *  ADC1_SE16                | ADC1_SE16/CMP2_IN2/ADC0_SE22                |                           | -       
 *  DAC0_OUT                 | DAC0_OUT/CMP1_IN3/ADC0_SE23                 |                           | -       
 *  DAC1_OUT                 | DAC1_OUT/CMP0_IN4/CMP2_IN3/ADC1_SE23        |                           | -       
 *  EXTAL32                  | EXTAL32                                     |                           | -       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           |                           | -       
 *  PTA1                     | JTAG_TDI                                    |                           | -       
 *  PTA2                     | JTAG_TDO/TRACE_SWO                          |                           | -       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            |                           | -       
 *  PTA4                     | NMI_b                                       |                           | -       
 *  PTA5                     | Disabled                                    |                           | -       
 *  PTA6                     | Disabled                                    |                           | -       
 *  PTA7                     | ADC0_SE10                                   |                           | -       
 *  PTA8                     | ADC0_SE11                                   |                           | -       
 *  PTA9                     | Disabled                                    |                           | -       
 *  PTA10                    | GPIOA_10/LLWU_P22                           | SW3                       | -       
 *  PTA11                    | GPIOA_11/LLWU_P23                           | LED_BLUE                  | -       
 *  PTA12                    | CMP2_IN0                                    |                           | -       
 *  PTA13                    | CMP2_IN1                                    |                           | -       
 *  PTA14                    | Disabled                                    |                           | -       
 *  PTA15                    | CMP3_IN1                                    |                           | -       
 *  PTA16                    | CMP3_IN2                                    |                           | -       
 *  PTA17                    | ADC1_SE17                                   |                           | -       
 *  PTA18                    | EXTAL0                                      |                           | -       
 *  PTA19                    | XTAL0                                       |                           | -       
 *  PTA24                    | CMP3_IN4                                    |                           | -       
 *  PTA25                    | GPIOA_25                                    | D7                        | -       
 *  PTA26                    | Disabled                                    |                           | -       
 *  PTA27                    | Disabled                                    |                           | -       
 *  PTA28                    | Disabled                                    |                           | -       
 *  PTA29                    | Disabled                                    |                           | -       
 *  PTB0                     | ADC0_SE8/ADC1_SE8/TSI0_CH0                  |                           | -       
 *  PTB1                     | ADC0_SE9/ADC1_SE9/TSI0_CH6                  |                           | -       
 *  PTB2                     | ADC0_SE12/TSI0_CH7                          | A5                        | -       
 *  PTB3                     | ADC0_SE13/TSI0_CH8                          | A4                        | -       
 *  PTB4                     | ADC1_SE10                                   | A3                        | -       
 *  PTB5                     | ADC1_SE11                                   | A2                        | -       
 *  PTB6                     | ADC1_SE12                                   | A1                        | -       
 *  PTB7                     | ADC1_SE13                                   | A0                        | -       
 *  PTB8                     | Disabled                                    |                           | -       
 *  PTB9                     | Disabled                                    |                           | -       
 *  PTB10                    | GPIOB_10                                    | D27                       | -       
 *  PTB11                    | GPIOB_11                                    | D28                       | -       
 *  PTB16                    | UART0_RX                                    | ConRx                     | -       
 *  PTB17                    | UART0_TX                                    | ConTx                     | -       
 *  PTB18                    | GPIOB_18                                    | D8                        | -       
 *  PTB19                    | GPIOB_19                                    | D9                        | -       
 *  PTB20                    | GPIOB_20                                    | nRF_ce_n                  | -       
 *  PTB21                    | Disabled                                    |                           | -       
 *  PTB22                    | Disabled                                    |                           | -       
 *  PTB23                    | GPIOB_23                                    | A10                       | -       
 *  PTC0                     | GPIOC_0                                     | D29                       | -       
 *  PTC1                     | GPIOC_1/LLWU_P6                             | D18                       | -       
 *  PTC2                     | GPIOC_2                                     | D6                        | -       
 *  PTC3                     | GPIOC_3/LLWU_P7                             | D0                        | -       
 *  PTC4                     | GPIOC_4/LLWU_P8                             | D1                        | -       
 *  PTC5                     | GPIOC_5/LLWU_P9                             | D5                        | -       
 *  PTC6                     | GPIOC_6/LLWU_P10                            | D19                       | -       
 *  PTC7                     | GPIOC_7                                     | D21                       | -       
 *  PTC8                     | GPIOC_8                                     | D3                        | -       
 *  PTC9                     | GPIOC_9                                     | LED_RED                   | -       
 *  PTC10                    | GPIOC_10                                    | D15                       | -       
 *  PTC11                    | GPIOC_11/LLWU_P11                           | D14                       | -       
 *  PTC12                    | GPIOC_12                                    | D4                        | -       
 *  PTC13                    | Disabled                                    |                           | -       
 *  PTC14                    | UART4_RX                                    | BLUETOOTH_Rx              | -       
 *  PTC15                    | UART4_TX                                    | BLUETOOTH_Tx              | -       
 *  PTC16                    | GPIOC_16                                    | D2                        | -       
 *  PTC17                    | Disabled                                    |                           | -       
 *  PTC18                    | GPIOC_18                                    | nRF_irq                   | -       
 *  PTC19                    | Disabled                                    |                           | -       
 *  PTD0                     | GPIOD_0/LLWU_P12                            | D10                       | -       
 *  PTD1                     | GPIOD_1                                     | D13                       | -       
 *  PTD2                     | GPIOD_2/LLWU_P13                            | D11                       | -       
 *  PTD3                     | GPIOD_3                                     | D12                       | -       
 *  PTD4                     | GPIOD_4/LLWU_P14                            | nRF_cs_n                  | -       
 *  PTD5                     | SPI1_SCK                                    | nRF_sck                   | -       
 *  PTD6                     | SPI1_SOUT                                   | nRF_mosi                  | -       
 *  PTD7                     | SPI1_SIN                                    | nRF_miso                  | -       
 *  PTD8                     | I2C0_SCL                                    | ONBOARD_SCL               | -       
 *  PTD9                     | I2C0_SDA                                    | ONBOARD_SDA               | -       
 *  PTD10                    | Disabled                                    |                           | -       
 *  PTD11                    | GPIOD_11/LLWU_P25                           | SW2                       | -       
 *  PTD12                    | GPIOD_12                                    | D33                       | -       
 *  PTD13                    | GPIOD_13                                    | D32                       | -       
 *  PTD14                    | Disabled                                    |                           | -       
 *  PTD15                    | Disabled                                    |                           | -       
 *  PTE0                     | ADC1_SE4a                                   |                           | -       
 *  PTE1                     | ADC1_SE5a                                   |                           | -       
 *  PTE2                     | ADC1_SE6a                                   |                           | -       
 *  PTE3                     | ADC1_SE7a                                   |                           | -       
 *  PTE4                     | Disabled                                    |                           | -       
 *  PTE5                     | Disabled                                    |                           | -       
 *  PTE6                     | GPIOE_6/LLWU_P16                            | LED_GREEN                 | -       
 *  PTE7                     | GPIOE_7                                     | D23                       | -       
 *  PTE8                     | GPIOE_8                                     | D22                       | -       
 *  PTE9                     | GPIOE_9/LLWU_P17                            | D20                       | -       
 *  PTE10                    | Disabled                                    |                           | -       
 *  PTE11                    | GPIOE_11                                    | D17                       | -       
 *  PTE12                    | GPIOE_12                                    | D16                       | -       
 *  PTE24                    | GPIOE_24                                    | D30                       | -       
 *  PTE25                    | GPIOE_25/LLWU_P21                           | D31                       | -       
 *  PTE26                    | Disabled                                    |                           | -       
 *  PTE27                    | Disabled                                    |                           | -       
 *  PTE28                    | Disabled                                    |                           | -       
 *  RESET_b                  | RESET_b                                     |                           | -       
 *  USB0_DM                  | USB0_DM                                     |                           | -       
 *  USB0_DP                  | USB0_DP                                     |                           | -       
 *  USB1_DM                  | Disabled                                    |                           | -       
 *  USB1_DP                  | Disabled                                    |                           | -       
 *  USB1_VBUS                | Disabled                                    |                           | -       
 *  USB1_VSS                 | Disabled                                    |                           | -       
 *  VBAT                     | VBAT                                        |                           | -       
 *  VDD1                     | VDD1                                        |                           | -       
 *  VDD2                     | VDD2                                        |                           | -       
 *  VDD3                     | VDD3                                        |                           | -       
 *  VDD4                     | VDD4                                        |                           | -       
 *  VDD5                     | VDD5                                        |                           | -       
 *  VDD6                     | VDD6                                        |                           | -       
 *  VDD7                     | VDD7                                        |                           | -       
 *  VDD8                     | VDD8                                        |                           | -       
 *  VDD9                     | VDD9                                        |                           | -       
 *  VDDA                     | VDDA                                        |                           | -       
 *  VREFH                    | VREFH                                       |                           | -       
 *  VREFL                    | VREFL                                       |                           | -       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5/ADC1_SE18        |                           | -       
 *  VREG_IN0                 | VREG_IN0                                    |                           | -       
 *  VREG_IN1                 | Disabled                                    |                           | -       
 *  VREG_OUT                 | VREG_OUT                                    |                           | -       
 *  VSS1                     | VSS1                                        |                           | -       
 *  VSS2a                    | VSS2a                                       |                           | -       
 *  VSS2b                    | VSS2b                                       |                           | -       
 *  VSS3                     | VSS3                                        |                           | -       
 *  VSS4                     | VSS4                                        |                           | -       
 *  VSS5                     | VSS5                                        |                           | -       
 *  VSS6                     | VSS6                                        |                           | -       
 *  VSS7                     | VSS7                                        |                           | -       
 *  VSS8                     | VSS8                                        |                           | -       
 *  VSS9                     | VSS9                                        |                           | -       
 *  VSSA                     | VSSA                                        |                           | -       
 *  XTAL32                   | XTAL32                                      |                           | -       
 *
 *
 * @section PinsByLocation Pins by Location
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTB7                     | ADC1_SE13                                   | A0                        | -       
 *  PTB6                     | ADC1_SE12                                   | A1                        | -       
 *  PTB5                     | ADC1_SE11                                   | A2                        | -       
 *  PTB4                     | ADC1_SE10                                   | A3                        | -       
 *  PTB3                     | ADC0_SE13/TSI0_CH8                          | A4                        | -       
 *  PTB2                     | ADC0_SE12/TSI0_CH7                          | A5                        | -       
 *  PTB23                    | GPIOB_23                                    | A10                       | -       
 *  PTC14                    | UART4_RX                                    | BLUETOOTH_Rx              | -       
 *  PTC15                    | UART4_TX                                    | BLUETOOTH_Tx              | -       
 *  PTB16                    | UART0_RX                                    | ConRx                     | -       
 *  PTB17                    | UART0_TX                                    | ConTx                     | -       
 *  PTC3                     | GPIOC_3/LLWU_P7                             | D0                        | -       
 *  PTC4                     | GPIOC_4/LLWU_P8                             | D1                        | -       
 *  PTC16                    | GPIOC_16                                    | D2                        | -       
 *  PTC8                     | GPIOC_8                                     | D3                        | -       
 *  PTC12                    | GPIOC_12                                    | D4                        | -       
 *  PTC5                     | GPIOC_5/LLWU_P9                             | D5                        | -       
 *  PTC2                     | GPIOC_2                                     | D6                        | -       
 *  PTA25                    | GPIOA_25                                    | D7                        | -       
 *  PTB18                    | GPIOB_18                                    | D8                        | -       
 *  PTB19                    | GPIOB_19                                    | D9                        | -       
 *  PTD0                     | GPIOD_0/LLWU_P12                            | D10                       | -       
 *  PTD2                     | GPIOD_2/LLWU_P13                            | D11                       | -       
 *  PTD3                     | GPIOD_3                                     | D12                       | -       
 *  PTD1                     | GPIOD_1                                     | D13                       | -       
 *  PTC11                    | GPIOC_11/LLWU_P11                           | D14                       | -       
 *  PTC10                    | GPIOC_10                                    | D15                       | -       
 *  PTE12                    | GPIOE_12                                    | D16                       | -       
 *  PTE11                    | GPIOE_11                                    | D17                       | -       
 *  PTC1                     | GPIOC_1/LLWU_P6                             | D18                       | -       
 *  PTC6                     | GPIOC_6/LLWU_P10                            | D19                       | -       
 *  PTE9                     | GPIOE_9/LLWU_P17                            | D20                       | -       
 *  PTC7                     | GPIOC_7                                     | D21                       | -       
 *  PTE8                     | GPIOE_8                                     | D22                       | -       
 *  PTE7                     | GPIOE_7                                     | D23                       | -       
 *  PTB10                    | GPIOB_10                                    | D27                       | -       
 *  PTB11                    | GPIOB_11                                    | D28                       | -       
 *  PTC0                     | GPIOC_0                                     | D29                       | -       
 *  PTE24                    | GPIOE_24                                    | D30                       | -       
 *  PTE25                    | GPIOE_25/LLWU_P21                           | D31                       | -       
 *  PTD13                    | GPIOD_13                                    | D32                       | -       
 *  PTD12                    | GPIOD_12                                    | D33                       | -       
 *  PTA11                    | GPIOA_11/LLWU_P23                           | LED_BLUE                  | -       
 *  PTE6                     | GPIOE_6/LLWU_P16                            | LED_GREEN                 | -       
 *  PTC9                     | GPIOC_9                                     | LED_RED                   | -       
 *  PTD8                     | I2C0_SCL                                    | ONBOARD_SCL               | -       
 *  PTD9                     | I2C0_SDA                                    | ONBOARD_SDA               | -       
 *  PTD11                    | GPIOD_11/LLWU_P25                           | SW2                       | -       
 *  PTA10                    | GPIOA_10/LLWU_P22                           | SW3                       | -       
 *  PTB20                    | GPIOB_20                                    | nRF_ce_n                  | -       
 *  PTD4                     | GPIOD_4/LLWU_P14                            | nRF_cs_n                  | -       
 *  PTC18                    | GPIOC_18                                    | nRF_irq                   | -       
 *  PTD7                     | SPI1_SIN                                    | nRF_miso                  | -       
 *  PTD6                     | SPI1_SOUT                                   | nRF_mosi                  | -       
 *  PTD5                     | SPI1_SCK                                    | nRF_sck                   | -       
 *
 *
 * @section PinsByFunction Pins by Function
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  ADC0_DM0                 | ADC0_DM0/ADC1_DM3                           |                           | -       
 *  PTB0                     | ADC0_SE8/ADC1_SE8/TSI0_CH0                  |                           | -       
 *  PTB1                     | ADC0_SE9/ADC1_SE9/TSI0_CH6                  |                           | -       
 *  PTA7                     | ADC0_SE10                                   |                           | -       
 *  PTA8                     | ADC0_SE11                                   |                           | -       
 *  PTB2                     | ADC0_SE12/TSI0_CH7                          | A5                        | -       
 *  PTB3                     | ADC0_SE13/TSI0_CH8                          | A4                        | -       
 *  ADC0_SE16                | ADC0_SE16/CMP1_IN2/ADC0_SE21                |                           | -       
 *  ADC1_DM0                 | ADC1_DM0/ADC0_DM3                           |                           | -       
 *  ADC1_DP0                 | ADC1_DP0/ADC0_DP3                           |                           | -       
 *  PTE0                     | ADC1_SE4a                                   |                           | -       
 *  PTE1                     | ADC1_SE5a                                   |                           | -       
 *  PTE2                     | ADC1_SE6a                                   |                           | -       
 *  PTE3                     | ADC1_SE7a                                   |                           | -       
 *  PTB4                     | ADC1_SE10                                   | A3                        | -       
 *  PTB5                     | ADC1_SE11                                   | A2                        | -       
 *  PTB6                     | ADC1_SE12                                   | A1                        | -       
 *  PTB7                     | ADC1_SE13                                   | A0                        | -       
 *  ADC1_SE16                | ADC1_SE16/CMP2_IN2/ADC0_SE22                |                           | -       
 *  PTA17                    | ADC1_SE17                                   |                           | -       
 *  PTA12                    | CMP2_IN0                                    |                           | -       
 *  PTA13                    | CMP2_IN1                                    |                           | -       
 *  PTA15                    | CMP3_IN1                                    |                           | -       
 *  PTA16                    | CMP3_IN2                                    |                           | -       
 *  PTA24                    | CMP3_IN4                                    |                           | -       
 *  DAC0_OUT                 | DAC0_OUT/CMP1_IN3/ADC0_SE23                 |                           | -       
 *  DAC1_OUT                 | DAC1_OUT/CMP0_IN4/CMP2_IN3/ADC1_SE23        |                           | -       
 *  VREG_IN1                 | Disabled                                    |                           | -       
 *  PTA18                    | EXTAL0                                      |                           | -       
 *  EXTAL32                  | EXTAL32                                     |                           | -       
 *  PTA10                    | GPIOA_10/LLWU_P22                           | SW3                       | -       
 *  PTA11                    | GPIOA_11/LLWU_P23                           | LED_BLUE                  | -       
 *  PTA25                    | GPIOA_25                                    | D7                        | -       
 *  PTB10                    | GPIOB_10                                    | D27                       | -       
 *  PTB11                    | GPIOB_11                                    | D28                       | -       
 *  PTB18                    | GPIOB_18                                    | D8                        | -       
 *  PTB19                    | GPIOB_19                                    | D9                        | -       
 *  PTB20                    | GPIOB_20                                    | nRF_ce_n                  | -       
 *  PTB23                    | GPIOB_23                                    | A10                       | -       
 *  PTC0                     | GPIOC_0                                     | D29                       | -       
 *  PTC1                     | GPIOC_1/LLWU_P6                             | D18                       | -       
 *  PTC2                     | GPIOC_2                                     | D6                        | -       
 *  PTC3                     | GPIOC_3/LLWU_P7                             | D0                        | -       
 *  PTC4                     | GPIOC_4/LLWU_P8                             | D1                        | -       
 *  PTC5                     | GPIOC_5/LLWU_P9                             | D5                        | -       
 *  PTC6                     | GPIOC_6/LLWU_P10                            | D19                       | -       
 *  PTC7                     | GPIOC_7                                     | D21                       | -       
 *  PTC8                     | GPIOC_8                                     | D3                        | -       
 *  PTC9                     | GPIOC_9                                     | LED_RED                   | -       
 *  PTC10                    | GPIOC_10                                    | D15                       | -       
 *  PTC11                    | GPIOC_11/LLWU_P11                           | D14                       | -       
 *  PTC12                    | GPIOC_12                                    | D4                        | -       
 *  PTC16                    | GPIOC_16                                    | D2                        | -       
 *  PTC18                    | GPIOC_18                                    | nRF_irq                   | -       
 *  PTD0                     | GPIOD_0/LLWU_P12                            | D10                       | -       
 *  PTD1                     | GPIOD_1                                     | D13                       | -       
 *  PTD2                     | GPIOD_2/LLWU_P13                            | D11                       | -       
 *  PTD3                     | GPIOD_3                                     | D12                       | -       
 *  PTD4                     | GPIOD_4/LLWU_P14                            | nRF_cs_n                  | -       
 *  PTD11                    | GPIOD_11/LLWU_P25                           | SW2                       | -       
 *  PTD12                    | GPIOD_12                                    | D33                       | -       
 *  PTD13                    | GPIOD_13                                    | D32                       | -       
 *  PTE6                     | GPIOE_6/LLWU_P16                            | LED_GREEN                 | -       
 *  PTE7                     | GPIOE_7                                     | D23                       | -       
 *  PTE8                     | GPIOE_8                                     | D22                       | -       
 *  PTE9                     | GPIOE_9/LLWU_P17                            | D20                       | -       
 *  PTE11                    | GPIOE_11                                    | D17                       | -       
 *  PTE12                    | GPIOE_12                                    | D16                       | -       
 *  PTE24                    | GPIOE_24                                    | D30                       | -       
 *  PTE25                    | GPIOE_25/LLWU_P21                           | D31                       | -       
 *  PTD8                     | I2C0_SCL                                    | ONBOARD_SCL               | -       
 *  PTD9                     | I2C0_SDA                                    | ONBOARD_SDA               | -       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           |                           | -       
 *  PTA1                     | JTAG_TDI                                    |                           | -       
 *  PTA2                     | JTAG_TDO/TRACE_SWO                          |                           | -       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            |                           | -       
 *  PTA4                     | NMI_b                                       |                           | -       
 *  RESET_b                  | RESET_b                                     |                           | -       
 *  PTD5                     | SPI1_SCK                                    | nRF_sck                   | -       
 *  PTD7                     | SPI1_SIN                                    | nRF_miso                  | -       
 *  PTD6                     | SPI1_SOUT                                   | nRF_mosi                  | -       
 *  PTB16                    | UART0_RX                                    | ConRx                     | -       
 *  PTB17                    | UART0_TX                                    | ConTx                     | -       
 *  PTC14                    | UART4_RX                                    | BLUETOOTH_Rx              | -       
 *  PTC15                    | UART4_TX                                    | BLUETOOTH_Tx              | -       
 *  USB0_DM                  | USB0_DM                                     |                           | -       
 *  USB0_DP                  | USB0_DP                                     |                           | -       
 *  VBAT                     | VBAT                                        |                           | -       
 *  VDD1                     | VDD1                                        |                           | -       
 *  VDD2                     | VDD2                                        |                           | -       
 *  VDD3                     | VDD3                                        |                           | -       
 *  VDD4                     | VDD4                                        |                           | -       
 *  VDD5                     | VDD5                                        |                           | -       
 *  VDD6                     | VDD6                                        |                           | -       
 *  VDD7                     | VDD7                                        |                           | -       
 *  VDD8                     | VDD8                                        |                           | -       
 *  VDD9                     | VDD9                                        |                           | -       
 *  VDDA                     | VDDA                                        |                           | -       
 *  VREFH                    | VREFH                                       |                           | -       
 *  VREFL                    | VREFL                                       |                           | -       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5/ADC1_SE18        |                           | -       
 *  VREG_IN0                 | VREG_IN0                                    |                           | -       
 *  VREG_OUT                 | VREG_OUT                                    |                           | -       
 *  VSS1                     | VSS1                                        |                           | -       
 *  VSS2a                    | VSS2a                                       |                           | -       
 *  VSS2b                    | VSS2b                                       |                           | -       
 *  VSS3                     | VSS3                                        |                           | -       
 *  VSS4                     | VSS4                                        |                           | -       
 *  VSS5                     | VSS5                                        |                           | -       
 *  VSS6                     | VSS6                                        |                           | -       
 *  VSS7                     | VSS7                                        |                           | -       
 *  VSS8                     | VSS8                                        |                           | -       
 *  VSS9                     | VSS9                                        |                           | -       
 *  VSSA                     | VSSA                                        |                           | -       
 *  PTA19                    | XTAL0                                       |                           | -       
 *  XTAL32                   | XTAL32                                      |                           | -       
 *
 */

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */
